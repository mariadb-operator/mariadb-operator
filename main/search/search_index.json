{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udea7\ud83d\udea7\ud83d\udea7 WIP \ud83d\udea7\ud83d\udea7\ud83d\udea7","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"API_REFERENCE/","title":"API Reference","text":""},{"location":"API_REFERENCE/#packages","title":"Packages","text":"<ul> <li>k8s.mariadb.com/v1alpha1</li> </ul>"},{"location":"API_REFERENCE/#k8smariadbcomv1alpha1","title":"k8s.mariadb.com/v1alpha1","text":"<p>Package v1alpha1 contains API Schema definitions for the v1alpha1 API group</p> <p>nolint:lll</p>"},{"location":"API_REFERENCE/#resource-types","title":"Resource Types","text":"<ul> <li>Backup</li> <li>Connection</li> <li>Database</li> <li>Grant</li> <li>MariaDB</li> <li>MaxScale</li> <li>Restore</li> <li>SqlJob</li> <li>User</li> </ul>"},{"location":"API_REFERENCE/#affinity","title":"Affinity","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#affinity-v1-core.</p> <p>Appears in: - AffinityConfig</p> Field Description Default Validation <code>podAntiAffinity</code> PodAntiAffinity"},{"location":"API_REFERENCE/#affinityconfig","title":"AffinityConfig","text":"<p>AffinityConfig defines policies to schedule Pods in Nodes.</p> <p>Appears in: - BackupSpec - Exporter - Job - JobPodTemplate - MariaDBSpec - MaxScalePodTemplate - MaxScaleSpec - PodTemplate - RestoreSpec - SqlJobSpec</p> Field Description Default Validation <code>podAntiAffinity</code> PodAntiAffinity <code>antiAffinityEnabled</code> boolean AntiAffinityEnabled configures PodAntiAffinity so each Pod is scheduled in a different Node, enabling HA.Make sure you have at least as many Nodes available as the replicas to not end up with unscheduled Pods."},{"location":"API_REFERENCE/#backup","title":"Backup","text":"<p>Backup is the Schema for the backups API. It is used to define backup jobs and its storage.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>Backup</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> BackupSpec"},{"location":"API_REFERENCE/#backupspec","title":"BackupSpec","text":"<p>BackupSpec defines the desired state of Backup</p> <p>Appears in: - Backup</p> Field Description Default Validation <code>args</code> string array Args to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container. <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod. <code>successfulJobsHistoryLimit</code> integer SuccessfulJobsHistoryLimit defines the maximum number of successful Jobs to be displayed. Minimum: 0  <code>failedJobsHistoryLimit</code> integer FailedJobsHistoryLimit defines the maximum number of failed Jobs to be displayed. Minimum: 0  <code>timeZone</code> string TimeZone defines the timezone associated with the cron expression. <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to a MariaDB object. Required: {}  <code>compression</code> CompressAlgorithm Compression algorithm to be used in the Backup. Enum: [none bzip2 gzip]  <code>storage</code> BackupStorage Storage to be used in the Backup. Required: {}  <code>schedule</code> Schedule Schedule defines when the Backup will be taken. <code>maxRetention</code> Duration MaxRetention defines the retention policy for backups. Old backups will be cleaned up by the Backup Job.It defaults to 30 days. <code>databases</code> string array Databases defines the logical databases to be backed up. If not provided, all databases are backed up. <code>ignoreGlobalPriv</code> boolean IgnoreGlobalPriv indicates to ignore the mysql.global_priv in backups.If not provided, it will default to true when the referred MariaDB instance has Galera enabled and otherwise to false.See: https://github.com/mariadb-operator/mariadb-operator/issues/556 <code>logLevel</code> string LogLevel to be used n the Backup Job. It defaults to 'info'. info <code>backoffLimit</code> integer BackoffLimit defines the maximum number of attempts to successfully take a Backup. <code>restartPolicy</code> RestartPolicy RestartPolicy to be added to the Backup Pod. OnFailure Enum: [Always OnFailure Never]  <code>inheritMetadata</code> Metadata InheritMetadata defines the metadata to be inherited by children resources."},{"location":"API_REFERENCE/#backupstorage","title":"BackupStorage","text":"<p>BackupStorage defines the storage for a Backup.</p> <p>Appears in: - BackupSpec</p> Field Description Default Validation <code>s3</code> S3 S3 defines the configuration to store backups in a S3 compatible storage. <code>persistentVolumeClaim</code> PersistentVolumeClaimSpec PersistentVolumeClaim is a Kubernetes PVC specification. <code>volume</code> VolumeSource Volume is a Kubernetes volume specification."},{"location":"API_REFERENCE/#basicauth","title":"BasicAuth","text":"<p>KubernetesAuth refers to the basic authentication mechanism utilized for establishing a connection from the operator to the agent.</p> <p>Appears in: - GaleraAgent</p> Field Description Default Validation <code>enabled</code> boolean Enabled is a flag to enable BasicAuth <code>username</code> string Username to be used for basic authentication <code>passwordSecretKeyRef</code> GeneratedSecretKeyRef PasswordSecretKeyRef to be used for basic authentication"},{"location":"API_REFERENCE/#bootstrapfrom","title":"BootstrapFrom","text":"<p>BootstrapFrom defines a source to bootstrap MariaDB from.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>backupRef</code> LocalObjectReference BackupRef is a reference to a Backup object. It has priority over S3 and Volume. <code>s3</code> S3 S3 defines the configuration to restore backups from a S3 compatible storage. It has priority over Volume. <code>volume</code> VolumeSource Volume is a Kubernetes Volume object that contains a backup. <code>targetRecoveryTime</code> Time TargetRecoveryTime is a RFC3339 (1970-01-01T00:00:00Z) date and time that defines the point in time recovery objective.It is used to determine the closest restoration source in time. <code>restoreJob</code> Job RestoreJob defines additional properties for the Job used to perform the Restore."},{"location":"API_REFERENCE/#cleanuppolicy","title":"CleanupPolicy","text":"<p>Underlying type: string</p> <p>CleanupPolicy defines the behavior for cleaning up a resource.</p> <p>Appears in: - DatabaseSpec - GrantSpec - SQLTemplate - UserSpec</p> Field Description <code>Skip</code> CleanupPolicySkip indicates that the resource will NOT be deleted from the database after the CR is deleted. <code>Delete</code> CleanupPolicyDelete indicates that the resource will be deleted from the database after the CR is deleted."},{"location":"API_REFERENCE/#compressalgorithm","title":"CompressAlgorithm","text":"<p>Underlying type: string</p> <p>CompressAlgorithm defines the compression algorithm for a Backup resource.</p> <p>Appears in: - BackupSpec</p> Field Description <code>none</code> No compression <code>bzip2</code> Bzip2 compression. Good compression ratio, but slower compression/decompression speed compared to gzip. <code>gzip</code> Gzip compression. Good compression/decompression speed, but worse compression ratio compared to bzip2."},{"location":"API_REFERENCE/#configmapkeyselector","title":"ConfigMapKeySelector","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#configmapkeyselector-v1-core.</p> <p>Appears in: - EnvVarSource - MariaDBSpec - SqlJobSpec</p> Field Description Default Validation <code>name</code> string <code>key</code> string"},{"location":"API_REFERENCE/#connection","title":"Connection","text":"<p>Connection is the Schema for the connections API. It is used to configure connection strings for the applications connecting to MariaDB.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>Connection</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> ConnectionSpec"},{"location":"API_REFERENCE/#connectionspec","title":"ConnectionSpec","text":"<p>ConnectionSpec defines the desired state of Connection</p> <p>Appears in: - Connection</p> Field Description Default Validation <code>secretName</code> string SecretName to be used in the Connection. <code>secretTemplate</code> SecretTemplate SecretTemplate to be used in the Connection. <code>healthCheck</code> HealthCheck HealthCheck to be used in the Connection. <code>params</code> object (keys:string, values:string) Params to be used in the Connection. <code>serviceName</code> string ServiceName to be used in the Connection. <code>port</code> integer Port to connect to. If not provided, it defaults to the MariaDB port or to the first MaxScale listener. <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to the MariaDB to connect to. Either MariaDBRef or MaxScaleRef must be provided. <code>maxScaleRef</code> ObjectReference MaxScaleRef is a reference to the MaxScale to connect to. Either MariaDBRef or MaxScaleRef must be provided. <code>username</code> string Username to use for configuring the Connection. Required: {}  <code>passwordSecretKeyRef</code> SecretKeySelector PasswordSecretKeyRef is a reference to the password to use for configuring the Connection.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. Required: {}  <code>host</code> string Host to connect to. If not provided, it defaults to the MariaDB host or to the MaxScale host. <code>database</code> string Database to use when configuring the Connection."},{"location":"API_REFERENCE/#connectiontemplate","title":"ConnectionTemplate","text":"<p>ConnectionTemplate defines a template to customize Connection objects.</p> <p>Appears in: - ConnectionSpec - MariaDBMaxScaleSpec - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>secretName</code> string SecretName to be used in the Connection. <code>secretTemplate</code> SecretTemplate SecretTemplate to be used in the Connection. <code>healthCheck</code> HealthCheck HealthCheck to be used in the Connection. <code>params</code> object (keys:string, values:string) Params to be used in the Connection. <code>serviceName</code> string ServiceName to be used in the Connection. <code>port</code> integer Port to connect to. If not provided, it defaults to the MariaDB port or to the first MaxScale listener."},{"location":"API_REFERENCE/#container","title":"Container","text":"<p>Container object definition.</p> <p>Appears in: - MariaDBSpec - PodTemplate</p> Field Description Default Validation <code>name</code> string Name to be given to the container. <code>image</code> string Image name to be used by the container. The supported format is <code>&lt;image&gt;:&lt;tag&gt;</code>. Required: {}  <code>imagePullPolicy</code> PullPolicy ImagePullPolicy is the image pull policy. One of <code>Always</code>, <code>Never</code> or <code>IfNotPresent</code>. If not defined, it defaults to <code>IfNotPresent</code>. Enum: [Always Never IfNotPresent]  <code>command</code> string array Command to be used in the Container. <code>args</code> string array Args to be used in the Container. <code>volumeMounts</code> VolumeMount array VolumeMounts to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements."},{"location":"API_REFERENCE/#containertemplate","title":"ContainerTemplate","text":"<p>ContainerTemplate defines a template to configure Container objects.</p> <p>Appears in: - GaleraAgent - GaleraInit - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>command</code> string array Command to be used in the Container. <code>args</code> string array Args to be used in the Container. <code>env</code> EnvVar array Env represents the environment variables to be injected in a container. <code>envFrom</code> EnvFromSource array EnvFrom represents the references (via ConfigMap and Secrets) to environment variables to be injected in the container. <code>volumeMounts</code> VolumeMount array VolumeMounts to be used in the Container. <code>livenessProbe</code> Probe LivenessProbe to be used in the Container. <code>readinessProbe</code> Probe ReadinessProbe to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container."},{"location":"API_REFERENCE/#cooperativemonitoring","title":"CooperativeMonitoring","text":"<p>Underlying type: string</p> <p>CooperativeMonitoring enables coordination between multiple MaxScale instances running monitors. See: https://mariadb.com/docs/server/architecture/components/maxscale/monitors/mariadbmon/use-cooperative-locking-ha-maxscale-mariadb-monitor/</p> <p>Appears in: - MaxScaleMonitor</p> Field Description <code>majority_of_all</code> CooperativeMonitoringMajorityOfAll requires a lock from the majority of the MariaDB servers, even the ones that are down. <code>majority_of_running</code> CooperativeMonitoringMajorityOfRunning requires a lock from the majority of the MariaDB servers."},{"location":"API_REFERENCE/#cronjobtemplate","title":"CronJobTemplate","text":"<p>CronJobTemplate defines parameters for configuring CronJob objects.</p> <p>Appears in: - BackupSpec - SqlJobSpec</p> Field Description Default Validation <code>successfulJobsHistoryLimit</code> integer SuccessfulJobsHistoryLimit defines the maximum number of successful Jobs to be displayed. Minimum: 0  <code>failedJobsHistoryLimit</code> integer FailedJobsHistoryLimit defines the maximum number of failed Jobs to be displayed. Minimum: 0  <code>timeZone</code> string TimeZone defines the timezone associated with the cron expression."},{"location":"API_REFERENCE/#database","title":"Database","text":"<p>Database is the Schema for the databases API. It is used to define a logical database as if you were running a 'CREATE DATABASE' statement.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>Database</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> DatabaseSpec"},{"location":"API_REFERENCE/#databasespec","title":"DatabaseSpec","text":"<p>DatabaseSpec defines the desired state of Database</p> <p>Appears in: - Database</p> Field Description Default Validation <code>requeueInterval</code> Duration RequeueInterval is used to perform requeue reconciliations. <code>retryInterval</code> Duration RetryInterval is the interval used to perform retries. <code>cleanupPolicy</code> CleanupPolicy CleanupPolicy defines the behavior for cleaning up a SQL resource. Enum: [Skip Delete]  <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to a MariaDB object. Required: {}  <code>characterSet</code> string CharacterSet to use in the Database. utf8 <code>collate</code> string Collate to use in the Database. utf8_general_ci <code>name</code> string Name overrides the default Database name provided by metadata.name. MaxLength: 80"},{"location":"API_REFERENCE/#envfromsource","title":"EnvFromSource","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#envfromsource-v1-core.</p> <p>Appears in: - ContainerTemplate - GaleraAgent - GaleraInit - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>prefix</code> string <code>configMapRef</code> LocalObjectReference <code>secretRef</code> LocalObjectReference"},{"location":"API_REFERENCE/#envvar","title":"EnvVar","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#envvarsource-v1-core.</p> <p>Appears in: - ContainerTemplate - GaleraAgent - GaleraInit - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>name</code> string Name of the environment variable. Must be a C_IDENTIFIER. <code>value</code> string <code>valueFrom</code> EnvVarSource"},{"location":"API_REFERENCE/#envvarsource","title":"EnvVarSource","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#envvarsource-v1-core.</p> <p>Appears in: - EnvVar</p> Field Description Default Validation <code>fieldRef</code> ObjectFieldSelector <code>configMapKeyRef</code> ConfigMapKeySelector <code>secretKeyRef</code> SecretKeySelector"},{"location":"API_REFERENCE/#execaction","title":"ExecAction","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#execaction-v1-core.</p> <p>Appears in: - Probe - ProbeHandler</p> Field Description Default Validation <code>command</code> string array"},{"location":"API_REFERENCE/#exporter","title":"Exporter","text":"<p>Exporter defines a metrics exporter container.</p> <p>Appears in: - MariadbMetrics - MaxScaleMetrics</p> Field Description Default Validation <code>image</code> string Image name to be used as metrics exporter. The supported format is <code>&lt;image&gt;:&lt;tag&gt;</code>.Only mysqld-exporter &gt;= v0.15.0 is supported: https://github.com/prometheus/mysqld_exporter <code>imagePullPolicy</code> PullPolicy ImagePullPolicy is the image pull policy. One of <code>Always</code>, <code>Never</code> or <code>IfNotPresent</code>. If not defined, it defaults to <code>IfNotPresent</code>. Enum: [Always Never IfNotPresent]  <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>port</code> integer Port where the exporter will be listening for connections. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>securityContext</code> SecurityContext SecurityContext holds container-level security attributes. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod."},{"location":"API_REFERENCE/#galera","title":"Galera","text":"<p>Galera allows you to enable multi-master HA via Galera in your MariaDB cluster.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>primary</code> PrimaryGalera Primary is the Galera configuration for the primary node. <code>sst</code> SST SST is the Snapshot State Transfer used when new Pods join the cluster.More info: https://galeracluster.com/library/documentation/sst.html. Enum: [rsync mariabackup mysqldump]  <code>availableWhenDonor</code> boolean AvailableWhenDonor indicates whether a donor node should be responding to queries. It defaults to false. <code>galeraLibPath</code> string GaleraLibPath is a path inside the MariaDB image to the wsrep provider plugin. It is defaulted if not provided.More info: https://galeracluster.com/library/documentation/mysql-wsrep-options.html#wsrep-provider. <code>replicaThreads</code> integer ReplicaThreads is the number of replica threads used to apply Galera write sets in parallel.More info: https://mariadb.com/kb/en/galera-cluster-system-variables/#wsrep_slave_threads. <code>providerOptions</code> object (keys:string, values:string) ProviderOptions is map of Galera configuration parameters.More info: https://mariadb.com/kb/en/galera-cluster-system-variables/#wsrep_provider_options. <code>agent</code> GaleraAgent GaleraAgent is a sidecar agent that co-operates with mariadb-operator. <code>recovery</code> GaleraRecovery GaleraRecovery is the recovery process performed by the operator whenever the Galera cluster is not healthy.More info: https://galeracluster.com/library/documentation/crash-recovery.html. <code>initContainer</code> GaleraInit InitContainer is an init container that runs in the MariaDB Pod and co-operates with mariadb-operator. <code>initJob</code> GaleraInitJob InitJob defines a Job that co-operates with mariadb-operator by performing initialization tasks. <code>config</code> GaleraConfig GaleraConfig defines storage options for the Galera configuration files. <code>enabled</code> boolean Enabled is a flag to enable Galera."},{"location":"API_REFERENCE/#galeraagent","title":"GaleraAgent","text":"<p>GaleraAgent is a sidecar agent that co-operates with mariadb-operator.</p> <p>Appears in: - Galera - GaleraSpec</p> Field Description Default Validation <code>command</code> string array Command to be used in the Container. <code>args</code> string array Args to be used in the Container. <code>env</code> EnvVar array Env represents the environment variables to be injected in a container. <code>envFrom</code> EnvFromSource array EnvFrom represents the references (via ConfigMap and Secrets) to environment variables to be injected in the container. <code>volumeMounts</code> VolumeMount array VolumeMounts to be used in the Container. <code>livenessProbe</code> Probe LivenessProbe to be used in the Container. <code>readinessProbe</code> Probe ReadinessProbe to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container. <code>image</code> string Image name to be used by the MariaDB instances. The supported format is <code>&lt;image&gt;:&lt;tag&gt;</code>. <code>imagePullPolicy</code> PullPolicy ImagePullPolicy is the image pull policy. One of <code>Always</code>, <code>Never</code> or <code>IfNotPresent</code>. If not defined, it defaults to <code>IfNotPresent</code>. Enum: [Always Never IfNotPresent]  <code>port</code> integer Port where the agent will be listening for connections. <code>kubernetesAuth</code> KubernetesAuth KubernetesAuth to be used by the agent container <code>basicAuth</code> BasicAuth BasicAuth to be used by the agent container <code>gracefulShutdownTimeout</code> Duration GracefulShutdownTimeout is the time we give to the agent container in order to gracefully terminate in-flight requests."},{"location":"API_REFERENCE/#galeraconfig","title":"GaleraConfig","text":"<p>GaleraConfig defines storage options for the Galera configuration files.</p> <p>Appears in: - Galera - GaleraSpec</p> Field Description Default Validation <code>reuseStorageVolume</code> boolean ReuseStorageVolume indicates that storage volume used by MariaDB should be reused to store the Galera configuration files.It defaults to false, which implies that a dedicated volume for the Galera configuration files is provisioned. <code>volumeClaimTemplate</code> VolumeClaimTemplate VolumeClaimTemplate is a template for the PVC that will contain the Galera configuration files shared between the InitContainer, Agent and MariaDB."},{"location":"API_REFERENCE/#galerainit","title":"GaleraInit","text":"<p>GaleraInit is an init container that runs in the MariaDB Pod and co-operates with mariadb-operator.</p> <p>Appears in: - Galera - GaleraSpec</p> Field Description Default Validation <code>command</code> string array Command to be used in the Container. <code>args</code> string array Args to be used in the Container. <code>env</code> EnvVar array Env represents the environment variables to be injected in a container. <code>envFrom</code> EnvFromSource array EnvFrom represents the references (via ConfigMap and Secrets) to environment variables to be injected in the container. <code>volumeMounts</code> VolumeMount array VolumeMounts to be used in the Container. <code>livenessProbe</code> Probe LivenessProbe to be used in the Container. <code>readinessProbe</code> Probe ReadinessProbe to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container. <code>image</code> string Image name to be used by the MariaDB instances. The supported format is <code>&lt;image&gt;:&lt;tag&gt;</code>. Required: {}  <code>imagePullPolicy</code> PullPolicy ImagePullPolicy is the image pull policy. One of <code>Always</code>, <code>Never</code> or <code>IfNotPresent</code>. If not defined, it defaults to <code>IfNotPresent</code>. Enum: [Always Never IfNotPresent]"},{"location":"API_REFERENCE/#galerainitjob","title":"GaleraInitJob","text":"<p>GaleraInitJob defines a Job used to be used to initialize the Galera cluster.</p> <p>Appears in: - Galera - GaleraSpec</p> Field Description Default Validation <code>metadata</code> Metadata Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements."},{"location":"API_REFERENCE/#galerarecovery","title":"GaleraRecovery","text":"<p>GaleraRecovery is the recovery process performed by the operator whenever the Galera cluster is not healthy. More info: https://galeracluster.com/library/documentation/crash-recovery.html.</p> <p>Appears in: - Galera - GaleraSpec</p> Field Description Default Validation <code>enabled</code> boolean Enabled is a flag to enable GaleraRecovery. <code>minClusterSize</code> IntOrString MinClusterSize is the minimum number of replicas to consider the cluster healthy. It can be either a number of replicas (1) or a percentage (50%).If Galera consistently reports less replicas than this value for the given 'ClusterHealthyTimeout' interval, a cluster recovery is iniated.It defaults to '1' replica, and it is highly recommendeded to keep this value at '1' in most cases.If set to more than one replica, the cluster recovery process may restart the healthy replicas as well. <code>clusterMonitorInterval</code> Duration ClusterMonitorInterval represents the interval used to monitor the Galera cluster health. <code>clusterHealthyTimeout</code> Duration ClusterHealthyTimeout represents the duration at which a Galera cluster, that consistently failed health checks,is considered unhealthy, and consequently the Galera recovery process will be initiated by the operator. <code>clusterBootstrapTimeout</code> Duration ClusterBootstrapTimeout is the time limit for bootstrapping a cluster.Once this timeout is reached, the Galera recovery state is reset and a new cluster bootstrap will be attempted. <code>clusterUpscaleTimeout</code> Duration ClusterUpscaleTimeout represents the maximum duration for upscaling the cluster's StatefulSet during the recovery process. <code>clusterDownscaleTimeout</code> Duration ClusterDownscaleTimeout represents the maximum duration for downscaling the cluster's StatefulSet during the recovery process. <code>podRecoveryTimeout</code> Duration PodRecoveryTimeout is the time limit for recevorying the sequence of a Pod during the cluster recovery. <code>podSyncTimeout</code> Duration PodSyncTimeout is the time limit for a Pod to join the cluster after having performed a cluster bootstrap during the cluster recovery. <code>forceClusterBootstrapInPod</code> string ForceClusterBootstrapInPod allows you to manually initiate the bootstrap process in a specific Pod.IMPORTANT: Use this option only in exceptional circumstances. Not selecting the Pod with the highest sequence number may result in data loss.IMPORTANT: Ensure you unset this field after completing the bootstrap to allow the operator to choose the appropriate Pod to bootstrap from in an event of cluster recovery. <code>job</code> GaleraRecoveryJob Job defines a Job that co-operates with mariadb-operator by performing the Galera cluster recovery ."},{"location":"API_REFERENCE/#galerarecoveryjob","title":"GaleraRecoveryJob","text":"<p>GaleraRecoveryJob defines a Job used to be used to recover the Galera cluster.</p> <p>Appears in: - GaleraRecovery</p> Field Description Default Validation <code>metadata</code> Metadata Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>podAffinity</code> boolean PodAffinity indicates whether the recovery Jobs should run in the same Node as the MariaDB Pods. It defaults to true."},{"location":"API_REFERENCE/#galeraspec","title":"GaleraSpec","text":"<p>GaleraSpec is the Galera desired state specification.</p> <p>Appears in: - Galera</p> Field Description Default Validation <code>primary</code> PrimaryGalera Primary is the Galera configuration for the primary node. <code>sst</code> SST SST is the Snapshot State Transfer used when new Pods join the cluster.More info: https://galeracluster.com/library/documentation/sst.html. Enum: [rsync mariabackup mysqldump]  <code>availableWhenDonor</code> boolean AvailableWhenDonor indicates whether a donor node should be responding to queries. It defaults to false. <code>galeraLibPath</code> string GaleraLibPath is a path inside the MariaDB image to the wsrep provider plugin. It is defaulted if not provided.More info: https://galeracluster.com/library/documentation/mysql-wsrep-options.html#wsrep-provider. <code>replicaThreads</code> integer ReplicaThreads is the number of replica threads used to apply Galera write sets in parallel.More info: https://mariadb.com/kb/en/galera-cluster-system-variables/#wsrep_slave_threads. <code>providerOptions</code> object (keys:string, values:string) ProviderOptions is map of Galera configuration parameters.More info: https://mariadb.com/kb/en/galera-cluster-system-variables/#wsrep_provider_options. <code>agent</code> GaleraAgent GaleraAgent is a sidecar agent that co-operates with mariadb-operator. <code>recovery</code> GaleraRecovery GaleraRecovery is the recovery process performed by the operator whenever the Galera cluster is not healthy.More info: https://galeracluster.com/library/documentation/crash-recovery.html. <code>initContainer</code> GaleraInit InitContainer is an init container that runs in the MariaDB Pod and co-operates with mariadb-operator. <code>initJob</code> GaleraInitJob InitJob defines a Job that co-operates with mariadb-operator by performing initialization tasks. <code>config</code> GaleraConfig GaleraConfig defines storage options for the Galera configuration files."},{"location":"API_REFERENCE/#generatedsecretkeyref","title":"GeneratedSecretKeyRef","text":"<p>GeneratedSecretKeyRef defines a reference to a Secret that can be automatically generated by mariadb-operator if needed.</p> <p>Appears in: - BasicAuth - MariaDBSpec - MariadbMetrics - MaxScaleAuth - ReplicaReplication</p> Field Description Default Validation <code>name</code> string <code>key</code> string <code>generate</code> boolean Generate indicates whether the Secret should be generated if the Secret referenced is not present. false"},{"location":"API_REFERENCE/#grant","title":"Grant","text":"<p>Grant is the Schema for the grants API. It is used to define grants as if you were running a 'GRANT' statement.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>Grant</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> GrantSpec"},{"location":"API_REFERENCE/#grantspec","title":"GrantSpec","text":"<p>GrantSpec defines the desired state of Grant</p> <p>Appears in: - Grant</p> Field Description Default Validation <code>requeueInterval</code> Duration RequeueInterval is used to perform requeue reconciliations. <code>retryInterval</code> Duration RetryInterval is the interval used to perform retries. <code>cleanupPolicy</code> CleanupPolicy CleanupPolicy defines the behavior for cleaning up a SQL resource. Enum: [Skip Delete]  <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to a MariaDB object. Required: {}  <code>privileges</code> string array Privileges to use in the Grant. MinItems: 1 Required: {}  <code>database</code> string Database to use in the Grant. * <code>table</code> string Table to use in the Grant. * <code>username</code> string Username to use in the Grant. Required: {}  <code>host</code> string Host to use in the Grant. It can be localhost, an IP or '%'. <code>grantOption</code> boolean GrantOption to use in the Grant. false"},{"location":"API_REFERENCE/#gtid","title":"Gtid","text":"<p>Underlying type: string</p> <p>Gtid indicates which Global Transaction ID should be used when connecting a replica to the master. See: https://mariadb.com/kb/en/gtid/#using-current_pos-vs-slave_pos.</p> <p>Appears in: - ReplicaReplication</p> Field Description <code>CurrentPos</code> GtidCurrentPos indicates the union of gtid_binlog_pos and gtid_slave_pos will be used when replicating from master.This is the default Gtid mode. <code>SlavePos</code> GtidSlavePos indicates that gtid_slave_pos will be used when replicating from master."},{"location":"API_REFERENCE/#httpgetaction","title":"HTTPGetAction","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#httpgetaction-v1-core.</p> <p>Appears in: - Probe - ProbeHandler</p> Field Description Default Validation <code>path</code> string <code>port</code> IntOrString <code>host</code> string <code>scheme</code> URIScheme"},{"location":"API_REFERENCE/#healthcheck","title":"HealthCheck","text":"<p>HealthCheck defines intervals for performing health checks.</p> <p>Appears in: - ConnectionSpec - ConnectionTemplate</p> Field Description Default Validation <code>interval</code> Duration Interval used to perform health checks. <code>retryInterval</code> Duration RetryInterval is the interval used to perform health check retries."},{"location":"API_REFERENCE/#job","title":"Job","text":"<p>Job defines a Job used to be used with MariaDB.</p> <p>Appears in: - BootstrapFrom</p> Field Description Default Validation <code>metadata</code> Metadata Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>args</code> string array Args to be used in the Container."},{"location":"API_REFERENCE/#jobcontainertemplate","title":"JobContainerTemplate","text":"<p>JobContainerTemplate defines a template to configure Container objects that run in a Job.</p> <p>Appears in: - BackupSpec - RestoreSpec - SqlJobSpec</p> Field Description Default Validation <code>args</code> string array Args to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container."},{"location":"API_REFERENCE/#jobpodtemplate","title":"JobPodTemplate","text":"<p>JobPodTemplate defines a template to configure Container objects that run in a Job.</p> <p>Appears in: - BackupSpec - RestoreSpec - SqlJobSpec</p> Field Description Default Validation <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod."},{"location":"API_REFERENCE/#kubernetesauth","title":"KubernetesAuth","text":"<p>KubernetesAuth refers to the Kubernetes authentication mechanism utilized for establishing a connection from the operator to the agent. The agent validates the legitimacy of the service account token provided as an Authorization header by creating a TokenReview resource.</p> <p>Appears in: - GaleraAgent</p> Field Description Default Validation <code>enabled</code> boolean Enabled is a flag to enable KubernetesAuth <code>authDelegatorRoleName</code> string AuthDelegatorRoleName is the name of the ClusterRoleBinding that is associated with the \"system:auth-delegator\" ClusterRole.It is necessary for creating TokenReview objects in order for the agent to validate the service account token."},{"location":"API_REFERENCE/#localobjectreference","title":"LocalObjectReference","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#localobjectreference-v1-core.</p> <p>Appears in: - BackupSpec - BootstrapFrom - ConfigMapKeySelector - EnvFromSource - Exporter - GeneratedSecretKeyRef - JobPodTemplate - MariaDBSpec - MaxScalePodTemplate - MaxScaleSpec - PodTemplate - RestoreSource - RestoreSpec - SecretKeySelector - SqlJobSpec</p> Field Description Default Validation <code>name</code> string"},{"location":"API_REFERENCE/#mariadb","title":"MariaDB","text":"<p>MariaDB is the Schema for the mariadbs API. It is used to define MariaDB clusters.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>MariaDB</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> MariaDBSpec"},{"location":"API_REFERENCE/#mariadbmaxscalespec","title":"MariaDBMaxScaleSpec","text":"<p>MariaDBMaxScaleSpec defines a reduced version of MaxScale to be used with the current MariaDB.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>enabled</code> boolean Enabled is a flag to enable a MaxScale instance to be used with the current MariaDB. <code>image</code> string Image name to be used by the MaxScale instances. The supported format is <code>&lt;image&gt;:&lt;tag&gt;</code>.Only MariaDB official images are supported. <code>imagePullPolicy</code> PullPolicy ImagePullPolicy is the image pull policy. One of <code>Always</code>, <code>Never</code> or <code>IfNotPresent</code>. If not defined, it defaults to <code>IfNotPresent</code>. Enum: [Always Never IfNotPresent]  <code>services</code> MaxScaleService array Services define how the traffic is forwarded to the MariaDB servers. <code>monitor</code> MaxScaleMonitor Monitor monitors MariaDB server instances. <code>admin</code> MaxScaleAdmin Admin configures the admin REST API and GUI. <code>config</code> MaxScaleConfig Config defines the MaxScale configuration. <code>auth</code> MaxScaleAuth Auth defines the credentials required for MaxScale to connect to MariaDB. <code>metrics</code> MaxScaleMetrics Metrics configures metrics and how to scrape them. <code>connection</code> ConnectionTemplate Connection provides a template to define the Connection for MaxScale. <code>replicas</code> integer Replicas indicates the number of desired instances. <code>podDisruptionBudget</code> PodDisruptionBudget PodDisruptionBudget defines the budget for replica availability. <code>updateStrategy</code> StatefulSetUpdateStrategy UpdateStrategy defines the update strategy for the StatefulSet object. <code>kubernetesService</code> ServiceTemplate KubernetesService defines a template for a Kubernetes Service object to connect to MaxScale. <code>guiKubernetesService</code> ServiceTemplate GuiKubernetesService define a template for a Kubernetes Service object to connect to MaxScale's GUI. <code>requeueInterval</code> Duration RequeueInterval is used to perform requeue reconciliations."},{"location":"API_REFERENCE/#mariadbref","title":"MariaDBRef","text":"<p>MariaDBRef is a reference to a MariaDB object.</p> <p>Appears in: - BackupSpec - ConnectionSpec - DatabaseSpec - GrantSpec - MaxScaleSpec - RestoreSpec - SqlJobSpec - UserSpec</p> Field Description Default Validation <code>name</code> string <code>namespace</code> string <code>waitForIt</code> boolean WaitForIt indicates whether the controller using this reference should wait for MariaDB to be ready. true"},{"location":"API_REFERENCE/#mariadbspec","title":"MariaDBSpec","text":"<p>MariaDBSpec defines the desired state of MariaDB</p> <p>Appears in: - MariaDB</p> Field Description Default Validation <code>command</code> string array Command to be used in the Container. <code>args</code> string array Args to be used in the Container. <code>env</code> EnvVar array Env represents the environment variables to be injected in a container. <code>envFrom</code> EnvFromSource array EnvFrom represents the references (via ConfigMap and Secrets) to environment variables to be injected in the container. <code>volumeMounts</code> VolumeMount array VolumeMounts to be used in the Container. <code>livenessProbe</code> Probe LivenessProbe to be used in the Container. <code>readinessProbe</code> Probe ReadinessProbe to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container. <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>initContainers</code> Container array InitContainers to be used in the Pod. <code>sidecarContainers</code> Container array SidecarContainers to be used in the Pod. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>volumes</code> Volume array Volumes to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod. <code>topologySpreadConstraints</code> TopologySpreadConstraint array TopologySpreadConstraints to be used in the Pod. <code>suspend</code> boolean Suspend indicates whether the current resource should be suspended or not.This can be useful for maintenance, as disabling the reconciliation prevents the operator from interfering with user operations during maintenance activities. false <code>image</code> string Image name to be used by the MariaDB instances. The supported format is <code>&lt;image&gt;:&lt;tag&gt;</code>.Only MariaDB official images are supported. <code>imagePullPolicy</code> PullPolicy ImagePullPolicy is the image pull policy. One of <code>Always</code>, <code>Never</code> or <code>IfNotPresent</code>. If not defined, it defaults to <code>IfNotPresent</code>. Enum: [Always Never IfNotPresent]  <code>inheritMetadata</code> Metadata InheritMetadata defines the metadata to be inherited by children resources. <code>rootPasswordSecretKeyRef</code> GeneratedSecretKeyRef RootPasswordSecretKeyRef is a reference to a Secret key containing the root password. <code>rootEmptyPassword</code> boolean RootEmptyPassword indicates if the root password should be empty. Don't use this feature in production, it is only intended for development and test environments. <code>database</code> string Database is the name of the initial Database. <code>username</code> string Username is the initial username to be created by the operator once MariaDB is ready. It has all privileges on the initial database.The initial User will have ALL PRIVILEGES in the initial Database. <code>passwordSecretKeyRef</code> GeneratedSecretKeyRef PasswordSecretKeyRef is a reference to a Secret that contains the password to be used by the initial User.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. <code>passwordHashSecretKeyRef</code> SecretKeySelector PasswordHashSecretKeyRef is a reference to the password hash to be used by the initial User.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password hash. <code>passwordPlugin</code> PasswordPlugin PasswordPlugin is a reference to the password plugin and arguments to be used by the initial User. <code>myCnf</code> string MyCnf allows to specify the my.cnf file mounted by Mariadb.Updating this field will trigger an update to the Mariadb resource. <code>myCnfConfigMapKeyRef</code> ConfigMapKeySelector MyCnfConfigMapKeyRef is a reference to the my.cnf config file provided via a ConfigMap.If not provided, it will be defaulted with a reference to a ConfigMap containing the MyCnf field.If the referred ConfigMap is labeled with \"k8s.mariadb.com/watch\", an update to the Mariadb resource will be triggered when the ConfigMap is updated. <code>timeZone</code> string TimeZone sets the default timezone. If not provided, it defaults to SYSTEM and the timezone data is not loaded. <code>bootstrapFrom</code> BootstrapFrom BootstrapFrom defines a source to bootstrap from. <code>storage</code> Storage Storage defines the storage options to be used for provisioning the PVCs mounted by MariaDB. <code>metrics</code> MariadbMetrics Metrics configures metrics and how to scrape them. <code>replication</code> Replication Replication configures high availability via replication. This feature is still in alpha, use Galera if you are looking for a more production-ready HA. <code>galera</code> Galera Replication configures high availability via Galera. <code>maxScaleRef</code> ObjectReference MaxScaleRef is a reference to a MaxScale resource to be used with the current MariaDB.Providing this field implies delegating high availability tasks such as primary failover to MaxScale. <code>maxScale</code> MariaDBMaxScaleSpec MaxScale is the MaxScale specification that defines the MaxScale resource to be used with the current MariaDB.When enabling this field, MaxScaleRef is automatically set. <code>replicas</code> integer Replicas indicates the number of desired instances. 1 <code>replicasAllowEvenNumber</code> boolean disables the validation check for an odd number of replicas. false <code>port</code> integer Port where the instances will be listening for connections. 3306 <code>servicePorts</code> ServicePort array ServicePorts is the list of additional named ports to be added to the Services created by the operator. <code>podDisruptionBudget</code> PodDisruptionBudget PodDisruptionBudget defines the budget for replica availability. <code>updateStrategy</code> UpdateStrategy UpdateStrategy defines how a MariaDB resource is updated. <code>service</code> ServiceTemplate Service defines a template to configure the general Service object.The network traffic of this Service will be routed to all Pods. <code>connection</code> ConnectionTemplate Connection defines a template to configure the general Connection object.This Connection provides the initial User access to the initial Database.It will make use of the Service to route network traffic to all Pods. <code>primaryService</code> ServiceTemplate PrimaryService defines a template to configure the primary Service object.The network traffic of this Service will be routed to the primary Pod. <code>primaryConnection</code> ConnectionTemplate PrimaryConnection defines a template to configure the primary Connection object.This Connection provides the initial User access to the initial Database.It will make use of the PrimaryService to route network traffic to the primary Pod. <code>secondaryService</code> ServiceTemplate SecondaryService defines a template to configure the secondary Service object.The network traffic of this Service will be routed to the secondary Pods. <code>secondaryConnection</code> ConnectionTemplate SecondaryConnection defines a template to configure the secondary Connection object.This Connection provides the initial User access to the initial Database.It will make use of the SecondaryService to route network traffic to the secondary Pods."},{"location":"API_REFERENCE/#mariadbmetrics","title":"MariadbMetrics","text":"<p>MariadbMetrics defines the metrics for a MariaDB.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>enabled</code> boolean Enabled is a flag to enable Metrics <code>exporter</code> Exporter Exporter defines the metrics exporter container. <code>serviceMonitor</code> ServiceMonitor ServiceMonitor defines the ServiceMonior object. <code>username</code> string Username is the username of the monitoring user used by the exporter. <code>passwordSecretKeyRef</code> GeneratedSecretKeyRef PasswordSecretKeyRef is a reference to the password of the monitoring user used by the exporter.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password."},{"location":"API_REFERENCE/#maxscale","title":"MaxScale","text":"<p>MaxScale is the Schema for the maxscales API. It is used to define MaxScale clusters.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>MaxScale</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> MaxScaleSpec"},{"location":"API_REFERENCE/#maxscaleadmin","title":"MaxScaleAdmin","text":"<p>MaxScaleAdmin configures the admin REST API and GUI.</p> <p>Appears in: - MariaDBMaxScaleSpec - MaxScaleSpec</p> Field Description Default Validation <code>port</code> integer Port where the admin REST API and GUI will be exposed. <code>guiEnabled</code> boolean GuiEnabled indicates whether the admin GUI should be enabled."},{"location":"API_REFERENCE/#maxscaleauth","title":"MaxScaleAuth","text":"<p>MaxScaleAuth defines the credentials required for MaxScale to connect to MariaDB.</p> <p>Appears in: - MariaDBMaxScaleSpec - MaxScaleSpec</p> Field Description Default Validation <code>generate</code> boolean Generate  defies whether the operator should generate users and grants for MaxScale to work.It only supports MariaDBs specified via spec.mariaDbRef. <code>adminUsername</code> string AdminUsername is an admin username to call the admin REST API. It is defaulted if not provided. <code>adminPasswordSecretKeyRef</code> GeneratedSecretKeyRef AdminPasswordSecretKeyRef is Secret key reference to the admin password to call the admin REST API. It is defaulted if not provided. <code>deleteDefaultAdmin</code> boolean DeleteDefaultAdmin determines whether the default admin user should be deleted after the initial configuration. If not provided, it defaults to true. <code>metricsUsername</code> string MetricsUsername is an metrics username to call the REST API. It is defaulted if metrics are enabled. <code>metricsPasswordSecretKeyRef</code> GeneratedSecretKeyRef MetricsPasswordSecretKeyRef is Secret key reference to the metrics password to call the admib REST API. It is defaulted if metrics are enabled.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. <code>clientUsername</code> string ClientUsername is the user to connect to MaxScale. It is defaulted if not provided. <code>clientPasswordSecretKeyRef</code> GeneratedSecretKeyRef ClientPasswordSecretKeyRef is Secret key reference to the password to connect to MaxScale. It is defaulted if not provided.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. <code>clientMaxConnections</code> integer ClientMaxConnections defines the maximum number of connections that the client can establish.If HA is enabled, make sure to increase this value, as more MaxScale replicas implies more connections.It defaults to 30 times the number of MaxScale replicas. <code>serverUsername</code> string ServerUsername is the user used by MaxScale to connect to MariaDB server. It is defaulted if not provided. <code>serverPasswordSecretKeyRef</code> GeneratedSecretKeyRef ServerPasswordSecretKeyRef is Secret key reference to the password used by MaxScale to connect to MariaDB server. It is defaulted if not provided.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. <code>serverMaxConnections</code> integer ServerMaxConnections defines the maximum number of connections that the server can establish.If HA is enabled, make sure to increase this value, as more MaxScale replicas implies more connections.It defaults to 30 times the number of MaxScale replicas. <code>monitorUsername</code> string MonitorUsername is the user used by MaxScale monitor to connect to MariaDB server. It is defaulted if not provided. <code>monitorPasswordSecretKeyRef</code> GeneratedSecretKeyRef MonitorPasswordSecretKeyRef is Secret key reference to the password used by MaxScale monitor to connect to MariaDB server. It is defaulted if not provided.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. <code>monitorMaxConnections</code> integer MonitorMaxConnections defines the maximum number of connections that the monitor can establish.If HA is enabled, make sure to increase this value, as more MaxScale replicas implies more connections.It defaults to 30 times the number of MaxScale replicas. <code>syncUsername</code> string MonitoSyncUsernamerUsername is the user used by MaxScale config sync to connect to MariaDB server. It is defaulted when HA is enabled. <code>syncPasswordSecretKeyRef</code> GeneratedSecretKeyRef SyncPasswordSecretKeyRef is Secret key reference to the password used by MaxScale config to connect to MariaDB server. It is defaulted when HA is enabled.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. <code>syncMaxConnections</code> integer SyncMaxConnections defines the maximum number of connections that the sync can establish.If HA is enabled, make sure to increase this value, as more MaxScale replicas implies more connections.It defaults to 30 times the number of MaxScale replicas."},{"location":"API_REFERENCE/#maxscaleconfig","title":"MaxScaleConfig","text":"<p>MaxScaleConfig defines the MaxScale configuration.</p> <p>Appears in: - MariaDBMaxScaleSpec - MaxScaleSpec</p> Field Description Default Validation <code>params</code> object (keys:string, values:string) Params is a key value pair of parameters to be used in the MaxScale static configuration file.Any parameter supported by MaxScale may be specified here. See reference:https://mariadb.com/kb/en/mariadb-maxscale-2308-mariadb-maxscale-configuration-guide/#global-settings. <code>volumeClaimTemplate</code> VolumeClaimTemplate VolumeClaimTemplate provides a template to define the PVCs for storing MaxScale runtime configuration files. It is defaulted if not provided. <code>sync</code> MaxScaleConfigSync Sync defines how to replicate configuration across MaxScale replicas. It is defaulted when HA is enabled."},{"location":"API_REFERENCE/#maxscaleconfigsync","title":"MaxScaleConfigSync","text":"<p>MaxScaleConfigSync defines how the config changes are replicated across replicas.</p> <p>Appears in: - MaxScaleConfig</p> Field Description Default Validation <code>database</code> string Database is the MariaDB logical database where the 'maxscale_config' table will be created in order to persist and synchronize config changes. If not provided, it defaults to 'mysql'. <code>interval</code> Duration Interval defines the config synchronization interval. It is defaulted if not provided. <code>timeout</code> Duration Interval defines the config synchronization timeout. It is defaulted if not provided."},{"location":"API_REFERENCE/#maxscalelistener","title":"MaxScaleListener","text":"<p>MaxScaleListener defines how the MaxScale server will listen for connections.</p> <p>Appears in: - MaxScaleService</p> Field Description Default Validation <code>suspend</code> boolean Suspend indicates whether the current resource should be suspended or not.This can be useful for maintenance, as disabling the reconciliation prevents the operator from interfering with user operations during maintenance activities. false <code>name</code> string Name is the identifier of the listener. It is defaulted if not provided <code>port</code> integer Port is the network port where the MaxScale server will listen. Required: {}  <code>protocol</code> string Protocol is the MaxScale protocol to use when communicating with the client. If not provided, it defaults to MariaDBProtocol. <code>params</code> object (keys:string, values:string) Params defines extra parameters to pass to the listener.Any parameter supported by MaxScale may be specified here. See reference:https://mariadb.com/kb/en/mariadb-maxscale-2308-mariadb-maxscale-configuration-guide/#listener_1."},{"location":"API_REFERENCE/#maxscalemetrics","title":"MaxScaleMetrics","text":"<p>MaxScaleMetrics defines the metrics for a Maxscale.</p> <p>Appears in: - MariaDBMaxScaleSpec - MaxScaleSpec</p> Field Description Default Validation <code>enabled</code> boolean Enabled is a flag to enable Metrics <code>exporter</code> Exporter Exporter defines the metrics exporter container. <code>serviceMonitor</code> ServiceMonitor ServiceMonitor defines the ServiceMonior object."},{"location":"API_REFERENCE/#maxscalemonitor","title":"MaxScaleMonitor","text":"<p>MaxScaleMonitor monitors MariaDB server instances</p> <p>Appears in: - MariaDBMaxScaleSpec - MaxScaleSpec</p> Field Description Default Validation <code>suspend</code> boolean Suspend indicates whether the current resource should be suspended or not.This can be useful for maintenance, as disabling the reconciliation prevents the operator from interfering with user operations during maintenance activities. false <code>name</code> string Name is the identifier of the monitor. It is defaulted if not provided. <code>module</code> MonitorModule Module is the module to use to monitor MariaDB servers. It is mandatory when no MariaDB reference is provided. <code>interval</code> Duration Interval used to monitor MariaDB servers. It is defaulted if not provided. <code>cooperativeMonitoring</code> CooperativeMonitoring CooperativeMonitoring enables coordination between multiple MaxScale instances running monitors. It is defaulted when HA is enabled. Enum: [majority_of_all majority_of_running]  <code>params</code> object (keys:string, values:string) Params defines extra parameters to pass to the monitor.Any parameter supported by MaxScale may be specified here. See reference:https://mariadb.com/kb/en/mariadb-maxscale-2308-common-monitor-parameters/.Monitor specific parameter are also suported:https://mariadb.com/kb/en/mariadb-maxscale-2308-galera-monitor/#galera-monitor-optional-parameters.https://mariadb.com/kb/en/mariadb-maxscale-2308-mariadb-monitor/#configuration."},{"location":"API_REFERENCE/#maxscalepodtemplate","title":"MaxScalePodTemplate","text":"<p>MaxScalePodTemplate defines a template for MaxScale Pods.</p> <p>Appears in: - MaxScaleSpec</p> Field Description Default Validation <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod. <code>topologySpreadConstraints</code> TopologySpreadConstraint array TopologySpreadConstraints to be used in the Pod."},{"location":"API_REFERENCE/#maxscaleserver","title":"MaxScaleServer","text":"<p>MaxScaleServer defines a MariaDB server to forward traffic to.</p> <p>Appears in: - MaxScaleSpec</p> Field Description Default Validation <code>name</code> string Name is the identifier of the MariaDB server. Required: {}  <code>address</code> string Address is the network address of the MariaDB server. Required: {}  <code>port</code> integer Port is the network port of the MariaDB server. If not provided, it defaults to 3306. <code>protocol</code> string Protocol is the MaxScale protocol to use when communicating with this MariaDB server. If not provided, it defaults to MariaDBBackend. <code>maintenance</code> boolean Maintenance indicates whether the server is in maintenance mode. <code>params</code> object (keys:string, values:string) Params defines extra parameters to pass to the server.Any parameter supported by MaxScale may be specified here. See reference:https://mariadb.com/kb/en/mariadb-maxscale-2308-mariadb-maxscale-configuration-guide/#server_1."},{"location":"API_REFERENCE/#maxscaleservice","title":"MaxScaleService","text":"<p>Services define how the traffic is forwarded to the MariaDB servers.</p> <p>Appears in: - MariaDBMaxScaleSpec - MaxScaleSpec</p> Field Description Default Validation <code>suspend</code> boolean Suspend indicates whether the current resource should be suspended or not.This can be useful for maintenance, as disabling the reconciliation prevents the operator from interfering with user operations during maintenance activities. false <code>name</code> string Name is the identifier of the MaxScale service. Required: {}  <code>router</code> ServiceRouter Router is the type of router to use. Enum: [readwritesplit readconnroute] Required: {}  <code>listener</code> MaxScaleListener MaxScaleListener defines how the MaxScale server will listen for connections. Required: {}  <code>params</code> object (keys:string, values:string) Params defines extra parameters to pass to the service.Any parameter supported by MaxScale may be specified here. See reference:https://mariadb.com/kb/en/mariadb-maxscale-2308-mariadb-maxscale-configuration-guide/#service_1.Router specific parameter are also suported:https://mariadb.com/kb/en/mariadb-maxscale-2308-readwritesplit/#configuration.https://mariadb.com/kb/en/mariadb-maxscale-2308-readconnroute/#configuration."},{"location":"API_REFERENCE/#maxscalespec","title":"MaxScaleSpec","text":"<p>MaxScaleSpec defines the desired state of MaxScale.</p> <p>Appears in: - MaxScale</p> Field Description Default Validation <code>command</code> string array Command to be used in the Container. <code>args</code> string array Args to be used in the Container. <code>env</code> EnvVar array Env represents the environment variables to be injected in a container. <code>envFrom</code> EnvFromSource array EnvFrom represents the references (via ConfigMap and Secrets) to environment variables to be injected in the container. <code>volumeMounts</code> VolumeMount array VolumeMounts to be used in the Container. <code>livenessProbe</code> Probe LivenessProbe to be used in the Container. <code>readinessProbe</code> Probe ReadinessProbe to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container. <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod. <code>topologySpreadConstraints</code> TopologySpreadConstraint array TopologySpreadConstraints to be used in the Pod. <code>suspend</code> boolean Suspend indicates whether the current resource should be suspended or not.This can be useful for maintenance, as disabling the reconciliation prevents the operator from interfering with user operations during maintenance activities. false <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to the MariaDB that MaxScale points to. It is used to initialize the servers field. <code>servers</code> MaxScaleServer array Servers are the MariaDB servers to forward traffic to. It is required if 'spec.mariaDbRef' is not provided. <code>image</code> string Image name to be used by the MaxScale instances. The supported format is <code>&lt;image&gt;:&lt;tag&gt;</code>.Only MaxScale official images are supported. <code>imagePullPolicy</code> PullPolicy ImagePullPolicy is the image pull policy. One of <code>Always</code>, <code>Never</code> or <code>IfNotPresent</code>. If not defined, it defaults to <code>IfNotPresent</code>. Enum: [Always Never IfNotPresent]  <code>inheritMetadata</code> Metadata InheritMetadata defines the metadata to be inherited by children resources. <code>services</code> MaxScaleService array Services define how the traffic is forwarded to the MariaDB servers. It is defaulted if not provided. <code>monitor</code> MaxScaleMonitor Monitor monitors MariaDB server instances. It is required if 'spec.mariaDbRef' is not provided. <code>admin</code> MaxScaleAdmin Admin configures the admin REST API and GUI. <code>config</code> MaxScaleConfig Config defines the MaxScale configuration. <code>auth</code> MaxScaleAuth Auth defines the credentials required for MaxScale to connect to MariaDB. <code>metrics</code> MaxScaleMetrics Metrics configures metrics and how to scrape them. <code>connection</code> ConnectionTemplate Connection provides a template to define the Connection for MaxScale. <code>replicas</code> integer Replicas indicates the number of desired instances. 1 <code>podDisruptionBudget</code> PodDisruptionBudget PodDisruptionBudget defines the budget for replica availability. <code>updateStrategy</code> StatefulSetUpdateStrategy UpdateStrategy defines the update strategy for the StatefulSet object. <code>kubernetesService</code> ServiceTemplate KubernetesService defines a template for a Kubernetes Service object to connect to MaxScale. <code>guiKubernetesService</code> ServiceTemplate GuiKubernetesService defines a template for a Kubernetes Service object to connect to MaxScale's GUI. <code>requeueInterval</code> Duration RequeueInterval is used to perform requeue reconciliations. If not defined, it defaults to 10s."},{"location":"API_REFERENCE/#metadata","title":"Metadata","text":"<p>Metadata defines the metadata to added to resources.</p> <p>Appears in: - BackupSpec - Exporter - GaleraInitJob - GaleraRecoveryJob - Job - JobPodTemplate - MariaDBSpec - MaxScalePodTemplate - MaxScaleSpec - PodTemplate - RestoreSpec - SecretTemplate - ServiceTemplate - SqlJobSpec - VolumeClaimTemplate</p> Field Description Default Validation <code>labels</code> object (keys:string, values:string) Labels to be added to children resources. <code>annotations</code> object (keys:string, values:string) Annotations to be added to children resources."},{"location":"API_REFERENCE/#monitormodule","title":"MonitorModule","text":"<p>Underlying type: string</p> <p>MonitorModule defines the type of monitor module</p> <p>Appears in: - MaxScaleMonitor</p> Field Description <code>mariadbmon</code> MonitorModuleMariadb is a monitor to be used with MariaDB servers. <code>galeramon</code> MonitorModuleGalera is a monitor to be used with Galera servers."},{"location":"API_REFERENCE/#objectfieldselector","title":"ObjectFieldSelector","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#objectfieldselector-v1-core.</p> <p>Appears in: - EnvVarSource</p> Field Description Default Validation <code>apiVersion</code> string <code>fieldPath</code> string"},{"location":"API_REFERENCE/#objectreference","title":"ObjectReference","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#objectreference-v1-core.</p> <p>Appears in: - ConnectionSpec - MariaDBRef - MariaDBSpec</p> Field Description Default Validation <code>name</code> string <code>namespace</code> string"},{"location":"API_REFERENCE/#passwordplugin","title":"PasswordPlugin","text":"<p>PasswordPlugin defines the password plugin and its arguments.</p> <p>Appears in: - MariaDBSpec - UserSpec</p> Field Description Default Validation <code>pluginNameSecretKeyRef</code> SecretKeySelector PluginNameSecretKeyRef is a reference to the authentication plugin to be used by the User.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the authentication plugin. <code>pluginArgSecretKeyRef</code> SecretKeySelector PluginArgSecretKeyRef is a reference to the arguments to be provided to the authentication plugin for the User.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the authentication plugin arguments."},{"location":"API_REFERENCE/#persistentvolumeclaimspec","title":"PersistentVolumeClaimSpec","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#persistentvolumeclaimspec-v1-core.</p> <p>Appears in: - BackupStorage - VolumeClaimTemplate</p> Field Description Default Validation <code>accessModes</code> PersistentVolumeAccessMode array <code>selector</code> LabelSelector <code>resources</code> VolumeResourceRequirements <code>storageClassName</code> string"},{"location":"API_REFERENCE/#podaffinityterm","title":"PodAffinityTerm","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#podaffinityterm-v1-core.</p> <p>Appears in: - PodAntiAffinity - WeightedPodAffinityTerm</p> Field Description Default Validation <code>labelSelector</code> LabelSelector <code>topologyKey</code> string"},{"location":"API_REFERENCE/#podantiaffinity","title":"PodAntiAffinity","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#podantiaffinity-v1-core.</p> <p>Appears in: - Affinity - AffinityConfig</p> Field Description Default Validation <code>requiredDuringSchedulingIgnoredDuringExecution</code> PodAffinityTerm array <code>preferredDuringSchedulingIgnoredDuringExecution</code> WeightedPodAffinityTerm array"},{"location":"API_REFERENCE/#poddisruptionbudget","title":"PodDisruptionBudget","text":"<p>PodDisruptionBudget is the Pod availability bundget for a MariaDB</p> <p>Appears in: - MariaDBMaxScaleSpec - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>minAvailable</code> IntOrString MinAvailable defines the number of minimum available Pods. <code>maxUnavailable</code> IntOrString MaxUnavailable defines the number of maximum unavailable Pods."},{"location":"API_REFERENCE/#podsecuritycontext","title":"PodSecurityContext","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#podsecuritycontext-v1-core</p> <p>Appears in: - BackupSpec - Exporter - JobPodTemplate - MariaDBSpec - MaxScalePodTemplate - MaxScaleSpec - PodTemplate - RestoreSpec - SqlJobSpec</p> Field Description Default Validation <code>seLinuxOptions</code> SELinuxOptions <code>runAsUser</code> integer <code>runAsGroup</code> integer <code>runAsNonRoot</code> boolean <code>supplementalGroups</code> integer array <code>fsGroup</code> integer <code>fsGroupChangePolicy</code> PodFSGroupChangePolicy <code>seccompProfile</code> SeccompProfile <code>appArmorProfile</code> AppArmorProfile"},{"location":"API_REFERENCE/#podtemplate","title":"PodTemplate","text":"<p>PodTemplate defines a template to configure Container objects.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>initContainers</code> Container array InitContainers to be used in the Pod. <code>sidecarContainers</code> Container array SidecarContainers to be used in the Pod. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>volumes</code> Volume array Volumes to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod. <code>topologySpreadConstraints</code> TopologySpreadConstraint array TopologySpreadConstraints to be used in the Pod."},{"location":"API_REFERENCE/#primarygalera","title":"PrimaryGalera","text":"<p>PrimaryGalera is the Galera configuration for the primary node.</p> <p>Appears in: - Galera - GaleraSpec</p> Field Description Default Validation <code>podIndex</code> integer PodIndex is the StatefulSet index of the primary node. The user may change this field to perform a manual switchover. <code>automaticFailover</code> boolean AutomaticFailover indicates whether the operator should automatically update PodIndex to perform an automatic primary failover."},{"location":"API_REFERENCE/#primaryreplication","title":"PrimaryReplication","text":"<p>PrimaryReplication is the replication configuration for the primary node.</p> <p>Appears in: - Replication - ReplicationSpec</p> Field Description Default Validation <code>podIndex</code> integer PodIndex is the StatefulSet index of the primary node. The user may change this field to perform a manual switchover. <code>automaticFailover</code> boolean AutomaticFailover indicates whether the operator should automatically update PodIndex to perform an automatic primary failover."},{"location":"API_REFERENCE/#probe","title":"Probe","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#probe-v1-core.</p> <p>Appears in: - ContainerTemplate - GaleraAgent - GaleraInit - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>exec</code> ExecAction <code>httpGet</code> HTTPGetAction <code>initialDelaySeconds</code> integer <code>timeoutSeconds</code> integer <code>periodSeconds</code> integer <code>successThreshold</code> integer <code>failureThreshold</code> integer"},{"location":"API_REFERENCE/#probehandler","title":"ProbeHandler","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#probe-v1-core.</p> <p>Appears in: - Probe</p> Field Description Default Validation <code>exec</code> ExecAction <code>httpGet</code> HTTPGetAction"},{"location":"API_REFERENCE/#replicareplication","title":"ReplicaReplication","text":"<p>ReplicaReplication is the replication configuration for the replica nodes.</p> <p>Appears in: - Replication - ReplicationSpec</p> Field Description Default Validation <code>waitPoint</code> WaitPoint WaitPoint defines whether the transaction should wait for ACK before committing to the storage engine.More info: https://mariadb.com/kb/en/semisynchronous-replication/#rpl_semi_sync_master_wait_point. Enum: [AfterSync AfterCommit]  <code>gtid</code> Gtid Gtid indicates which Global Transaction ID should be used when connecting a replica to the master.See: https://mariadb.com/kb/en/gtid/#using-current_pos-vs-slave_pos. Enum: [CurrentPos SlavePos]  <code>replPasswordSecretKeyRef</code> GeneratedSecretKeyRef ReplPasswordSecretKeyRef provides a reference to the Secret to use as password for the replication user. <code>connectionTimeout</code> Duration ConnectionTimeout to be used when the replica connects to the primary. <code>connectionRetries</code> integer ConnectionRetries to be used when the replica connects to the primary. <code>syncTimeout</code> Duration SyncTimeout defines the timeout for a replica to be synced with the primary when performing a primary switchover.If the timeout is reached, the replica GTID will be reset and the switchover will continue."},{"location":"API_REFERENCE/#replication","title":"Replication","text":"<p>Replication allows you to enable single-master HA via semi-synchronours replication in your MariaDB cluster.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>primary</code> PrimaryReplication Primary is the replication configuration for the primary node. <code>replica</code> ReplicaReplication ReplicaReplication is the replication configuration for the replica nodes. <code>syncBinlog</code> boolean SyncBinlog indicates whether the binary log should be synchronized to the disk after every event.It trades off performance for consistency.See: https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#sync_binlog. <code>probesEnabled</code> boolean ProbesEnabled indicates to use replication specific liveness and readiness probes.This probes check that the primary can receive queries and that the replica has the replication thread running. <code>enabled</code> boolean Enabled is a flag to enable Replication."},{"location":"API_REFERENCE/#replicationspec","title":"ReplicationSpec","text":"<p>ReplicationSpec is the Replication desired state specification.</p> <p>Appears in: - Replication</p> Field Description Default Validation <code>primary</code> PrimaryReplication Primary is the replication configuration for the primary node. <code>replica</code> ReplicaReplication ReplicaReplication is the replication configuration for the replica nodes. <code>syncBinlog</code> boolean SyncBinlog indicates whether the binary log should be synchronized to the disk after every event.It trades off performance for consistency.See: https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#sync_binlog. <code>probesEnabled</code> boolean ProbesEnabled indicates to use replication specific liveness and readiness probes.This probes check that the primary can receive queries and that the replica has the replication thread running."},{"location":"API_REFERENCE/#resourcerequirements","title":"ResourceRequirements","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#resourcerequirements-v1-core.</p> <p>Appears in: - BackupSpec - Container - ContainerTemplate - Exporter - GaleraAgent - GaleraInit - GaleraInitJob - GaleraRecoveryJob - Job - JobContainerTemplate - MariaDBSpec - MaxScaleSpec - RestoreSpec - SqlJobSpec</p>"},{"location":"API_REFERENCE/#restore","title":"Restore","text":"<p>Restore is the Schema for the restores API. It is used to define restore jobs and its restoration source.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>Restore</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> RestoreSpec"},{"location":"API_REFERENCE/#restoresource","title":"RestoreSource","text":"<p>RestoreSource defines a source for restoring a MariaDB.</p> <p>Appears in: - BootstrapFrom - RestoreSpec</p> Field Description Default Validation <code>backupRef</code> LocalObjectReference BackupRef is a reference to a Backup object. It has priority over S3 and Volume. <code>s3</code> S3 S3 defines the configuration to restore backups from a S3 compatible storage. It has priority over Volume. <code>volume</code> VolumeSource Volume is a Kubernetes Volume object that contains a backup. <code>targetRecoveryTime</code> Time TargetRecoveryTime is a RFC3339 (1970-01-01T00:00:00Z) date and time that defines the point in time recovery objective.It is used to determine the closest restoration source in time."},{"location":"API_REFERENCE/#restorespec","title":"RestoreSpec","text":"<p>RestoreSpec defines the desired state of restore</p> <p>Appears in: - Restore</p> Field Description Default Validation <code>args</code> string array Args to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container. <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod. <code>backupRef</code> LocalObjectReference BackupRef is a reference to a Backup object. It has priority over S3 and Volume. <code>s3</code> S3 S3 defines the configuration to restore backups from a S3 compatible storage. It has priority over Volume. <code>volume</code> VolumeSource Volume is a Kubernetes Volume object that contains a backup. <code>targetRecoveryTime</code> Time TargetRecoveryTime is a RFC3339 (1970-01-01T00:00:00Z) date and time that defines the point in time recovery objective.It is used to determine the closest restoration source in time. <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to a MariaDB object. Required: {}  <code>database</code> string Database defines the logical database to be restored. If not provided, all databases available in the backup are restored.IMPORTANT: The database must previously exist. <code>logLevel</code> string LogLevel to be used n the Backup Job. It defaults to 'info'. info <code>backoffLimit</code> integer BackoffLimit defines the maximum number of attempts to successfully perform a Backup. 5 <code>restartPolicy</code> RestartPolicy RestartPolicy to be added to the Backup Job. OnFailure Enum: [Always OnFailure Never]  <code>inheritMetadata</code> Metadata InheritMetadata defines the metadata to be inherited by children resources."},{"location":"API_REFERENCE/#s3","title":"S3","text":"<p>Appears in: - BackupStorage - BootstrapFrom - RestoreSource - RestoreSpec</p> Field Description Default Validation <code>bucket</code> string Bucket is the name Name of the bucket to store backups. Required: {}  <code>endpoint</code> string Endpoint is the S3 API endpoint without scheme. Required: {}  <code>region</code> string Region is the S3 region name to use. <code>prefix</code> string Prefix indicates a folder/subfolder in the bucket. For example: mariadb/ or mariadb/backups. A trailing slash '/' is added if not provided. <code>accessKeyIdSecretKeyRef</code> SecretKeySelector AccessKeyIdSecretKeyRef is a reference to a Secret key containing the S3 access key id. Required: {}  <code>secretAccessKeySecretKeyRef</code> SecretKeySelector AccessKeyIdSecretKeyRef is a reference to a Secret key containing the S3 secret key. Required: {}  <code>sessionTokenSecretKeyRef</code> SecretKeySelector SessionTokenSecretKeyRef is a reference to a Secret key containing the S3 session token. <code>tls</code> TLS TLS provides the configuration required to establish TLS connections with S3."},{"location":"API_REFERENCE/#sqltemplate","title":"SQLTemplate","text":"<p>SQLTemplate defines a template to customize SQL objects.</p> <p>Appears in: - DatabaseSpec - GrantSpec - UserSpec</p> Field Description Default Validation <code>requeueInterval</code> Duration RequeueInterval is used to perform requeue reconciliations. <code>retryInterval</code> Duration RetryInterval is the interval used to perform retries. <code>cleanupPolicy</code> CleanupPolicy CleanupPolicy defines the behavior for cleaning up a SQL resource. Enum: [Skip Delete]"},{"location":"API_REFERENCE/#sst","title":"SST","text":"<p>Underlying type: string</p> <p>SST is the Snapshot State Transfer used when new Pods join the cluster. More info: https://galeracluster.com/library/documentation/sst.html.</p> <p>Appears in: - Galera - GaleraSpec</p> Field Description <code>rsync</code> SSTRsync is an SST based on rsync. <code>mariabackup</code> SSTMariaBackup is an SST based on mariabackup. It is the recommended SST. <code>mysqldump</code> SSTMysqldump is an SST based on mysqldump."},{"location":"API_REFERENCE/#schedule","title":"Schedule","text":"<p>Schedule contains parameters to define a schedule</p> <p>Appears in: - BackupSpec - SqlJobSpec</p> Field Description Default Validation <code>cron</code> string Cron is a cron expression that defines the schedule. Required: {}  <code>suspend</code> boolean Suspend defines whether the schedule is active or not. false"},{"location":"API_REFERENCE/#secretkeyselector","title":"SecretKeySelector","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#secretkeyselector-v1-core.</p> <p>Appears in: - ConnectionSpec - EnvVarSource - GeneratedSecretKeyRef - MariaDBSpec - PasswordPlugin - S3 - SqlJobSpec - TLS - UserSpec</p> Field Description Default Validation <code>name</code> string <code>key</code> string"},{"location":"API_REFERENCE/#secrettemplate","title":"SecretTemplate","text":"<p>SecretTemplate defines a template to customize Secret objects.</p> <p>Appears in: - ConnectionSpec - ConnectionTemplate</p> Field Description Default Validation <code>metadata</code> Metadata Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>key</code> string Key to be used in the Secret. <code>format</code> string Format to be used in the Secret. <code>usernameKey</code> string UsernameKey to be used in the Secret. <code>passwordKey</code> string PasswordKey to be used in the Secret. <code>hostKey</code> string HostKey to be used in the Secret. <code>portKey</code> string PortKey to be used in the Secret. <code>databaseKey</code> string DatabaseKey to be used in the Secret."},{"location":"API_REFERENCE/#securitycontext","title":"SecurityContext","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#securitycontext-v1-core.</p> <p>Appears in: - BackupSpec - ContainerTemplate - Exporter - GaleraAgent - GaleraInit - JobContainerTemplate - MariaDBSpec - MaxScaleSpec - RestoreSpec - SqlJobSpec</p> Field Description Default Validation <code>capabilities</code> Capabilities <code>privileged</code> boolean <code>runAsUser</code> integer <code>runAsGroup</code> integer <code>runAsNonRoot</code> boolean <code>readOnlyRootFilesystem</code> boolean <code>allowPrivilegeEscalation</code> boolean"},{"location":"API_REFERENCE/#servicemonitor","title":"ServiceMonitor","text":"<p>ServiceMonitor defines a prometheus ServiceMonitor object.</p> <p>Appears in: - MariadbMetrics - MaxScaleMetrics</p> Field Description Default Validation <code>prometheusRelease</code> string PrometheusRelease is the release label to add to the ServiceMonitor object. <code>jobLabel</code> string JobLabel to add to the ServiceMonitor object. <code>interval</code> string Interval for scraping metrics. <code>scrapeTimeout</code> string ScrapeTimeout defines the timeout for scraping metrics."},{"location":"API_REFERENCE/#serviceport","title":"ServicePort","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#serviceport-v1-core</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>name</code> string <code>port</code> integer"},{"location":"API_REFERENCE/#servicerouter","title":"ServiceRouter","text":"<p>Underlying type: string</p> <p>ServiceRouter defines the type of service router.</p> <p>Appears in: - MaxScaleService</p> Field Description <code>readwritesplit</code> ServiceRouterReadWriteSplit splits the load based on the queries. Write queries are performed on master and read queries on the replicas. <code>readconnroute</code> ServiceRouterReadConnRoute splits the load based on the connections. Each connection is assigned to a server."},{"location":"API_REFERENCE/#servicetemplate","title":"ServiceTemplate","text":"<p>ServiceTemplate defines a template to customize Service objects.</p> <p>Appears in: - MariaDBMaxScaleSpec - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>type</code> ServiceType Type is the Service type. One of <code>ClusterIP</code>, <code>NodePort</code> or <code>LoadBalancer</code>. If not defined, it defaults to <code>ClusterIP</code>. ClusterIP Enum: [ClusterIP NodePort LoadBalancer]  <code>metadata</code> Metadata Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>loadBalancerIP</code> string LoadBalancerIP Service field. <code>loadBalancerSourceRanges</code> string array LoadBalancerSourceRanges Service field. <code>externalTrafficPolicy</code> ServiceExternalTrafficPolicy ExternalTrafficPolicy Service field. <code>sessionAffinity</code> ServiceAffinity SessionAffinity Service field. <code>allocateLoadBalancerNodePorts</code> boolean AllocateLoadBalancerNodePorts Service field."},{"location":"API_REFERENCE/#sqljob","title":"SqlJob","text":"<p>SqlJob is the Schema for the sqljobs API. It is used to run sql scripts as jobs.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>SqlJob</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> SqlJobSpec"},{"location":"API_REFERENCE/#sqljobspec","title":"SqlJobSpec","text":"<p>SqlJobSpec defines the desired state of SqlJob</p> <p>Appears in: - SqlJob</p> Field Description Default Validation <code>args</code> string array Args to be used in the Container. <code>resources</code> ResourceRequirements Resouces describes the compute resource requirements. <code>securityContext</code> SecurityContext SecurityContext holds security configuration that will be applied to a container. <code>podMetadata</code> Metadata PodMetadata defines extra metadata for the Pod. <code>imagePullSecrets</code> LocalObjectReference array ImagePullSecrets is the list of pull Secrets to be used to pull the image. <code>podSecurityContext</code> PodSecurityContext SecurityContext holds pod-level security attributes and common container settings. <code>serviceAccountName</code> string ServiceAccountName is the name of the ServiceAccount to be used by the Pods. <code>affinity</code> AffinityConfig Affinity to be used in the Pod. <code>nodeSelector</code> object (keys:string, values:string) NodeSelector to be used in the Pod. <code>tolerations</code> Toleration array Tolerations to be used in the Pod. <code>priorityClassName</code> string PriorityClassName to be used in the Pod. <code>successfulJobsHistoryLimit</code> integer SuccessfulJobsHistoryLimit defines the maximum number of successful Jobs to be displayed. Minimum: 0  <code>failedJobsHistoryLimit</code> integer FailedJobsHistoryLimit defines the maximum number of failed Jobs to be displayed. Minimum: 0  <code>timeZone</code> string TimeZone defines the timezone associated with the cron expression. <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to a MariaDB object. Required: {}  <code>schedule</code> Schedule Schedule defines when the SqlJob will be executed. <code>username</code> string Username to be impersonated when executing the SqlJob. Required: {}  <code>passwordSecretKeyRef</code> SecretKeySelector UserPasswordSecretKeyRef is a reference to the impersonated user's password to be used when executing the SqlJob. Required: {}  <code>database</code> string Username to be used when executing the SqlJob. <code>dependsOn</code> LocalObjectReference array DependsOn defines dependencies with other SqlJob objectecs. <code>sql</code> string Sql is the script to be executed by the SqlJob. <code>sqlConfigMapKeyRef</code> ConfigMapKeySelector SqlConfigMapKeyRef is a reference to a ConfigMap containing the Sql script.It is defaulted to a ConfigMap with the contents of the Sql field. <code>backoffLimit</code> integer BackoffLimit defines the maximum number of attempts to successfully execute a SqlJob. 5 <code>restartPolicy</code> RestartPolicy RestartPolicy to be added to the SqlJob Pod. OnFailure Enum: [Always OnFailure Never]  <code>inheritMetadata</code> Metadata InheritMetadata defines the metadata to be inherited by children resources."},{"location":"API_REFERENCE/#storage","title":"Storage","text":"<p>Storage defines the storage options to be used for provisioning the PVCs mounted by MariaDB.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>ephemeral</code> boolean Ephemeral indicates whether to use ephemeral storage in the PVCs. It is only compatible with non HA MariaDBs. <code>size</code> Quantity Size of the PVCs to be mounted by MariaDB. Required if not provided in 'VolumeClaimTemplate'. It superseeds the storage size specified in 'VolumeClaimTemplate'. <code>storageClassName</code> string StorageClassName to be used to provision the PVCS. It superseeds the 'StorageClassName' specified in 'VolumeClaimTemplate'.If not provided, the default 'StorageClass' configured in the cluster is used. <code>resizeInUseVolumes</code> boolean ResizeInUseVolumes indicates whether the PVCs can be resized. The 'StorageClassName' used should have 'allowVolumeExpansion' set to 'true' to allow resizing.It defaults to true. <code>waitForVolumeResize</code> boolean WaitForVolumeResize indicates whether to wait for the PVCs to be resized before marking the MariaDB object as ready. This will block other operations such as cluster recovery while the resize is in progress.It defaults to true. <code>volumeClaimTemplate</code> VolumeClaimTemplate VolumeClaimTemplate provides a template to define the PVCs."},{"location":"API_REFERENCE/#suspendtemplate","title":"SuspendTemplate","text":"<p>SuspendTemplate indicates whether the current resource should be suspended or not.</p> <p>Appears in: - MariaDBSpec - MaxScaleListener - MaxScaleMonitor - MaxScaleService - MaxScaleSpec</p> Field Description Default Validation <code>suspend</code> boolean Suspend indicates whether the current resource should be suspended or not.This can be useful for maintenance, as disabling the reconciliation prevents the operator from interfering with user operations during maintenance activities. false"},{"location":"API_REFERENCE/#tls","title":"TLS","text":"<p>Appears in: - S3</p> Field Description Default Validation <code>enabled</code> boolean Enabled is a flag to enable TLS. <code>caSecretKeyRef</code> SecretKeySelector CASecretKeyRef is a reference to a Secret key containing a CA bundle in PEM format used to establish TLS connections with S3.By default, the system trust chain will be used, but you can use this field to add more CAs to the bundle."},{"location":"API_REFERENCE/#topologyspreadconstraint","title":"TopologySpreadConstraint","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#topologyspreadconstraint-v1-core.</p> <p>Appears in: - MariaDBSpec - MaxScalePodTemplate - MaxScaleSpec - PodTemplate</p> Field Description Default Validation <code>maxSkew</code> integer <code>topologyKey</code> string <code>whenUnsatisfiable</code> UnsatisfiableConstraintAction <code>labelSelector</code> LabelSelector <code>minDomains</code> integer <code>nodeAffinityPolicy</code> NodeInclusionPolicy <code>nodeTaintsPolicy</code> NodeInclusionPolicy <code>matchLabelKeys</code> string array"},{"location":"API_REFERENCE/#updatestrategy","title":"UpdateStrategy","text":"<p>UpdateStrategy defines how a MariaDB resource is updated.</p> <p>Appears in: - MariaDBSpec</p> Field Description Default Validation <code>type</code> UpdateType Type defines the type of updates. One of <code>ReplicasFirstPrimaryLast</code>, <code>RollingUpdate</code> or <code>OnDelete</code>. If not defined, it defaults to <code>ReplicasFirstPrimaryLast</code>. ReplicasFirstPrimaryLast Enum: [ReplicasFirstPrimaryLast RollingUpdate OnDelete Never]  <code>rollingUpdate</code> RollingUpdateStatefulSetStrategy RollingUpdate defines parameters for the RollingUpdate type. <code>autoUpdateDataPlane</code> boolean AutoUpdateDataPlane indicates whether the Galera data-plane version (agent and init containers) should be automatically updated based on the operator version. It defaults to false.Updating the operator will trigger updates on all the MariaDB instances that have this flag set to true. Thus, it is recommended to progressively set this flag after having updated the operator."},{"location":"API_REFERENCE/#updatetype","title":"UpdateType","text":"<p>Underlying type: string</p> <p>UpdateType defines the type of update for a MariaDB resource.</p> <p>Appears in: - UpdateStrategy</p> Field Description <code>ReplicasFirstPrimaryLast</code> ReplicasFirstPrimaryLastUpdateType indicates that the update will be applied to all replica Pods first and later on to the primary Pod.The updates are applied one by one waiting until each Pod passes the readiness probei.e. the Pod gets synced and it is ready to receive traffic. <code>RollingUpdate</code> RollingUpdateUpdateType indicates that the update will be applied by the StatefulSet controller using the RollingUpdate strategy.This strategy is unaware of the roles that the Pod have (primary or replica) and it willperform the update following the StatefulSet ordinal, from higher to lower. <code>OnDelete</code> OnDeleteUpdateType indicates that the update will be applied by the StatefulSet controller using the OnDelete strategy.The update will be done when the Pods get manually deleted by the user. <code>Never</code> NeverUpdateType indicates that the StatefulSet will never be updated.This can be used to roll out updates progressively to a fleet of instances."},{"location":"API_REFERENCE/#user","title":"User","text":"<p>User is the Schema for the users API.  It is used to define grants as if you were running a 'CREATE USER' statement.</p> Field Description Default Validation <code>apiVersion</code> string <code>k8s.mariadb.com/v1alpha1</code> <code>kind</code> string <code>User</code> <code>metadata</code> ObjectMeta Refer to Kubernetes API documentation for fields of <code>metadata</code>. <code>spec</code> UserSpec"},{"location":"API_REFERENCE/#userspec","title":"UserSpec","text":"<p>UserSpec defines the desired state of User</p> <p>Appears in: - User</p> Field Description Default Validation <code>requeueInterval</code> Duration RequeueInterval is used to perform requeue reconciliations. <code>retryInterval</code> Duration RetryInterval is the interval used to perform retries. <code>cleanupPolicy</code> CleanupPolicy CleanupPolicy defines the behavior for cleaning up a SQL resource. Enum: [Skip Delete]  <code>mariaDbRef</code> MariaDBRef MariaDBRef is a reference to a MariaDB object. Required: {}  <code>passwordSecretKeyRef</code> SecretKeySelector PasswordSecretKeyRef is a reference to the password to be used by the User.If not provided, the account will be locked and the password will expire.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password. <code>passwordHashSecretKeyRef</code> SecretKeySelector PasswordHashSecretKeyRef is a reference to the password hash to be used by the User.If the referred Secret is labeled with \"k8s.mariadb.com/watch\", updates may be performed to the Secret in order to update the password hash. <code>passwordPlugin</code> PasswordPlugin PasswordPlugin is a reference to the password plugin and arguments to be used by the User. <code>maxUserConnections</code> integer MaxUserConnections defines the maximum number of simultaneous connections that the User can establish. 10 <code>name</code> string Name overrides the default name provided by metadata.name. MaxLength: 80  <code>host</code> string Host related to the User. MaxLength: 255"},{"location":"API_REFERENCE/#volume","title":"Volume","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#volume-v1-core.</p> <p>Appears in: - MariaDBSpec - PodTemplate</p> Field Description Default Validation <code>name</code> string <code>emptyDir</code> EmptyDirVolumeSource <code>nfs</code> NFSVolumeSource <code>csi</code> CSIVolumeSource <code>persistentVolumeClaim</code> PersistentVolumeClaimVolumeSource"},{"location":"API_REFERENCE/#volumeclaimtemplate","title":"VolumeClaimTemplate","text":"<p>VolumeClaimTemplate defines a template to customize PVC objects.</p> <p>Appears in: - GaleraConfig - MaxScaleConfig - Storage</p> Field Description Default Validation <code>accessModes</code> PersistentVolumeAccessMode array <code>selector</code> LabelSelector <code>resources</code> VolumeResourceRequirements <code>storageClassName</code> string <code>metadata</code> Metadata Refer to Kubernetes API documentation for fields of <code>metadata</code>."},{"location":"API_REFERENCE/#volumemount","title":"VolumeMount","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#volumemount-v1-core.</p> <p>Appears in: - Container - ContainerTemplate - GaleraAgent - GaleraInit - MariaDBSpec - MaxScaleSpec</p> Field Description Default Validation <code>name</code> string This must match the Name of a Volume. <code>readOnly</code> boolean <code>mountPath</code> string <code>subPath</code> string"},{"location":"API_REFERENCE/#volumesource","title":"VolumeSource","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#volume-v1-core.</p> <p>Appears in: - BackupStorage - BootstrapFrom - RestoreSource - RestoreSpec - Volume</p> Field Description Default Validation <code>emptyDir</code> EmptyDirVolumeSource <code>nfs</code> NFSVolumeSource <code>csi</code> CSIVolumeSource <code>persistentVolumeClaim</code> PersistentVolumeClaimVolumeSource"},{"location":"API_REFERENCE/#waitpoint","title":"WaitPoint","text":"<p>Underlying type: string</p> <p>WaitPoint defines whether the transaction should wait for ACK before committing to the storage engine. More info: https://mariadb.com/kb/en/semisynchronous-replication/#rpl_semi_sync_master_wait_point.</p> <p>Appears in: - ReplicaReplication</p> Field Description <code>AfterSync</code> WaitPointAfterSync indicates that the primary waits for the replica ACK before committing the transaction to the storage engine.This is the default WaitPoint. It trades off performance for consistency. <code>AfterCommit</code> WaitPointAfterCommit indicates that the primary commits the transaction to the storage engine and waits for the replica ACK afterwards.It trades off consistency for performance."},{"location":"API_REFERENCE/#weightedpodaffinityterm","title":"WeightedPodAffinityTerm","text":"<p>Refer to the Kubernetes docs: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/#weightedpodaffinityterm-v1-core.</p> <p>Appears in: - PodAntiAffinity</p> Field Description Default Validation <code>weight</code> integer <code>podAffinityTerm</code> PodAffinityTerm"},{"location":"BACKUP/","title":"Backup and Restore","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.28</p> <p><code>mariadb-operator</code> allows you to declarativaly take backups by defining <code>Backup</code> resources and later on restore them by using their <code>Restore</code> counterpart. These resources get reconciled into <code>Job</code>/<code>CronJob</code> resources that automatically perform the backup/restore operations, so you don't need to manually script them.</p>"},{"location":"BACKUP/#table-of-contents","title":"Table of contents","text":"<ul> <li>Storage types</li> <li><code>Backup</code> CR</li> <li><code>Restore</code> CR</li> <li>Bootstrap new <code>MariaDB</code> instances</li> <li>Backup and restore specific databases</li> <li>Extra options</li> <li>Important considerations and limitations</li> <li>Logical backups</li> <li>Migrating an external MariaDB to a <code>MariaDB</code> running in Kubernetes</li> <li>Migrating to a <code>MariaDB</code> with different topology</li> <li>Minio reference installation</li> <li>Reference</li> <li>Troubleshooting</li> </ul>"},{"location":"BACKUP/#storage-types","title":"Storage types","text":"<p>Currently, the following storage types are supported: - S3 compatible storage: Store backups in a S3 compatible storage, such as AWS S3 or Minio.  - PVCs: Use the available StorageClasses in your Kubernetes cluster to provision a PVC dedicated to store the backup files. - Kubernetes volumes: Use any of the volume types supported natively by Kubernetes.</p> <p>Our recommendation is to store the backups externally in a S3 compatible storage. Minio makes this incredibly easy, take a look at our Minio reference installation to quickly spin up an instance.</p>"},{"location":"BACKUP/#backup-cr","title":"<code>Backup</code> CR","text":"<p>You can take a one-time backup of your <code>MariaDB</code> instance by declaring the following resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  storage:\n    persistentVolumeClaim:\n      resources:\n        requests:\n          storage: 100Mi\n      accessModes:\n        - ReadWriteOnce\n</code></pre> <p>This will use the default <code>StorageClass</code> to provision a PVC that would hold the backup files, but ideally you should use a S3 compatible storage:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  storage:\n    s3:\n      bucket: backups\n      prefix: mariadb\n      endpoint: minio.minio.svc.cluster.local:9000\n      region:  us-east-1\n      accessKeyIdSecretKeyRef:\n        name: minio\n        key: access-key-id\n      secretAccessKeySecretKeyRef:\n        name: minio\n        key: secret-access-key\n      tls:\n        enabled: true\n        caSecretKeyRef:\n          name: minio-ca\n          key: ca.crt\n</code></pre> <p>By providing the authentication details and the TLS configuration via references to <code>Secret</code> keys, this example will store the backups in a local Minio instance.</p>"},{"location":"BACKUP/#scheduling","title":"Scheduling","text":"<p>To minimize the Recovery Point Objective (RPO) and mitigate the risk of data loss, it is recommended to perform backups regularly. You can do so by providing a <code>spec.schedule</code> in your <code>Backup</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  schedule:\n    cron: \"*/1 * * * *\"\n    suspend: false\n</code></pre> <p>This resource gets reconciled into a <code>CronJob</code> that periodically takes the backups.</p> <p>It is important to note that regularly scheduled <code>Backups</code> complement very well the target recovery time feature detailed below.</p>"},{"location":"BACKUP/#retention-policy","title":"Retention policy","text":"<p>Given that the backups can consume a substantial amount of storage, it is crucial to define your retention policy by providing the <code>spec.maxRetention</code> field in your <code>Backup</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  maxRetention: 720h # 30 days\n</code></pre>"},{"location":"BACKUP/#compression","title":"Compression","text":"<p>You are able to compress backups by providing the compression algorithm you want to use in the  <code>spec.compression</code> field:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  compression: gzip\n</code></pre> <p>Currently the following compression algorithms are supported: - <code>bzip2</code>: Good compression ratio, but slower compression/decompression speed compared to gzip. - <code>gzip</code>: Good compression/decompression speed, but worse compression ratio compared to bzip2. - <code>none</code>: No compression.</p> <p><code>compression</code> is defaulted to <code>none</code> by the operator.</p>"},{"location":"BACKUP/#restore-cr","title":"<code>Restore</code> CR","text":"<p>You can easily restore a <code>Backup</code> in your <code>MariaDB</code> instance by creating the following resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Restore\nmetadata:\n  name: restore\nspec:\n  mariaDbRef:\n    name: mariadb\n  backupRef:\n    name: backup\n</code></pre> <p>This will trigger a <code>Job</code> that will mount the same storage as the <code>Backup</code> and apply the dump to your <code>MariaDB</code> database.</p> <p>Nevertheless, the <code>Restore</code> resource doesn't necessarily need to specify a <code>spec.backupRef</code>, you can point to other storage source that contains backup files, for example a S3 bucket:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Restore\nmetadata:\n  name: restore\nspec:\n  mariaDbRef:\n    name: mariadb\n  s3:\n    bucket: backups\n    prefix: mariadb\n    endpoint: minio.minio.svc.cluster.local:9000\n    region:  us-east-1\n    accessKeyIdSecretKeyRef:\n      name: minio\n      key: access-key-id\n    secretAccessKeySecretKeyRef:\n      name: minio\n      key: secret-access-key\n    tls:\n      enabled: true\n      caSecretKeyRef:\n        name: minio-ca\n        key: ca.crt\n</code></pre>"},{"location":"BACKUP/#target-recovery-time","title":"Target recovery time","text":"<p>If you have multiple backups available, specially after configuring a scheduled Backup, the operator is able to infer which backup to restore based on the <code>spec.targetRecoveryTime</code> field.</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Restore\nmetadata:\n  name: restore\nspec:\n  mariaDbRef:\n    name: mariadb\n  backupRef:\n    name: backup\n  targetRecoveryTime: 2023-12-19T09:00:00Z\n</code></pre> <p>The operator will look for the closest backup available and utilize it to restore your <code>MariaDB</code> instance.</p> <p>By default, <code>spec.targetRecoveryTime</code> will be set to the current time, which means that the latest available backup will be used.</p>"},{"location":"BACKUP/#bootstrap-new-mariadb-instances","title":"Bootstrap new <code>MariaDB</code> instances","text":"<p>To minimize your Recovery Time Objective (RTO) and to switfly spin up new clusters from existing <code>Backups</code>, you can provide a <code>Restore</code> source directly in the <code>MariaDB</code> object via the <code>spec.bootstrapFrom</code> field:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-from-backup\nspec:\n  storage:\n    size: 1Gi\n  bootstrapFrom:\n    backupRef:\n      name: backup\n    targetRecoveryTime: 2023-12-19T09:00:00Z\n</code></pre> <p>As in the <code>Restore</code> resource, you don't strictly need to specify a reference to a <code>Backup</code>, you can provide other storage types that contain backup files:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-from-backup\nspec:\n  storage:\n    size: 1Gi\n  bootstrapFrom:\n    s3:\n      bucket: backups\n      prefix: mariadb\n      endpoint: minio.minio.svc.cluster.local:9000\n      accessKeyIdSecretKeyRef:\n        name: minio\n        key: access-key-id\n      secretAccessKeySecretKeyRef:\n        name: minio\n        key: secret-access-key\n      tls:\n        enabled: true\n        caSecretKeyRef:\n          name: minio-ca\n          key: ca.crt\n    targetRecoveryTime: 2023-12-19T09:00:00Z\n</code></pre> <p>Under the hood, the operator creates a <code>Restore</code> object just after the <code>MariaDB</code> resource becomes ready. The advantage of using <code>spec.bootstrapFrom</code> over a standalone <code>Restore</code> is that the <code>MariaDB</code> is bootstrap-aware and this will allow the operator to hold primary switchover/failover operations until the restoration is finished.</p>"},{"location":"BACKUP/#backup-and-restore-specific-databases","title":"Backup and restore specific databases","text":"<p>By default, all the logical databases are backed up when a <code>Backup</code> is created, but you may also select specific databases by providing the <code>databases</code> field:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  databases:\n    - db1\n    - db2\n    - db3\n</code></pre> <p>When it comes to restore, all the databases available in the backup will be restored, but you may also choose a single database to be restored via the  <code>database</code> field available in the <code>Restore</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Restore\nmetadata:\n  name: restore\nspec:\n  mariaDbRef:\n    name: mariadb\n  backupRef:\n    name: backup\n  databases: db1\n</code></pre> <p>There are a couple of points to consider here: - The referred database (<code>db1</code> in the example) must previously exist for the <code>Restore</code> to succeed. - The <code>mariadb</code> CLI invoked by the operator under the hood only supports selecting a single database to restore via the <code>--one-database</code> option, restoration of multiple specific databases is not supported.</p>"},{"location":"BACKUP/#extra-options","title":"Extra options","text":"<p>Not all the flags supported by <code>mariadb-dump</code> and <code>mariadb</code> have their counterpart field in the <code>Backup</code> and <code>Restore</code> CRs respectively, but you may pass extra options by using the <code>args</code> field. For example, setting the <code>--verbose</code> flag can be helpful to track the progress of backup and restore operations:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  args:\n    - --verbose\n</code></pre> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Restore\nmetadata:\n  name: restore\nspec:\n  mariaDbRef:\n    name: mariadb\n  backupRef:\n    name: backup\n  args:\n    - --verbose\n</code></pre> <p>Refer to the <code>mariadb-dump</code> and <code>mariadb</code> CLI options in the reference section.</p>"},{"location":"BACKUP/#important-considerations-and-limitations","title":"Important considerations and limitations","text":""},{"location":"BACKUP/#root-credentials","title":"Root credentials","text":"<p>When restoring a backup, the root credentials specified through the <code>spec.rootPasswordSecretKeyRef</code> field in the <code>MariaDB</code> resource must match the ones in the backup. These credentials are utilized by the liveness and readiness probes, and if they are invalid, the probes will fail, causing your <code>MariaDB</code> <code>Pods</code> to restart after the backup restoration.</p>"},{"location":"BACKUP/#restore-job","title":"Restore job","text":"<p>Restoring large backups can consume significant compute resources and may cause <code>Restore</code> <code>Jobs</code> to become stuck due to insufficient resources. To prevent this, you can define the compute resources allocated to the <code>Job</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  storage:\n    size: 1Gi\n  bootstrapFrom:\n    restoreJob:\n      args:\n        - --verbose\n      resources:\n        requests:\n          cpu: 100m\n          memory: 128Mi\n        limits:\n          memory: 1Gi\n</code></pre>"},{"location":"BACKUP/#galera-backup-limitations","title":"Galera backup limitations","text":""},{"location":"BACKUP/#mysqlglobal_priv","title":"<code>mysql.global_priv</code>","text":"<p>Galera only replicates the tables with InnoDB engine: - https://galeracluster.com/library/kb/user-changes.html</p> <p>Something that does not include <code>mysql.global_priv</code>, the table used to store users and grants, which uses the MyISAM engine. This basically means that a Galera instance with <code>mysql.global_priv</code> populated will not replicate this data to an empty Galera instance. However, DDL statements (<code>CREATE USER</code>, <code>ALTER USER</code> ...) will be replicated.</p> <p>Taking this into account, if we think now about a restore scenario where: - The backup file includes a <code>DROP TABLE</code> statement for the <code>mysql.global_priv</code> table. - The backup has some <code>INSERT</code> statements for the <code>mysql.global_priv</code> table. - The Galera cluster has 3 nodes: <code>galera-0</code>, <code>galera-1</code> and <code>galera-2</code>. - The backup is restored in <code>galera-0</code>.</p> <p>This is what will happen under the scenes while restoring the backup: - The <code>DROP TABLE</code> statement is a DDL so it will be executed in <code>galera-0</code>, <code>galera-1</code> and <code>galera-2</code>. - The <code>INSERT</code> statements are not DDLs, so they will only be applied to <code>galera-0</code>. - This results in the <code>galera-1</code> and <code>galera-2</code> not having the <code>mysql.global_priv</code> table.</p> <p>After the backup is fully restored, the liveness and readiness probes will kick in, they will succeed in <code>galera-0</code>, but they will fail in <code>galera-1</code> and <code>galera-2</code>, as they rely in the root credentials available in <code>mysql.global_priv</code>, resulting in the <code>galera-1</code> and <code>galera-2</code> getting restarted.</p> <p>To address this issue, when backing up <code>MariaDB</code> instances with Galera enabled, the <code>mysql.global_priv</code> table will be excluded from backups by using the <code>--ignore-table</code> option with <code>mariadb-dump</code>. This prevents the replication of the <code>DROP TABLE</code> statement for the <code>mysql.global_priv</code> table. You can opt-out from this feature by setting <code>spec.ignoreGlobalPriv=false</code> in the <code>Backup</code> resource.</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb\n  ignoreGlobalPriv: false\n</code></pre> <p>Also, to avoid situations where <code>mysql.global_priv</code> is unreplicated, all the entries in that table must be managed via DDLs. This is the recommended approach suggested in the Galera docs. There are a couple of ways that we can guarantee this: - Use the <code>rootPasswordSecretKeyRef</code>, <code>username</code> and <code>passwordSecretKeyRef</code> fields of the <code>MariaDB</code> CR to create the root and initial user respectively. This fields will be translated into DDLs by the image entrypoint. - Rely on the <code>User</code> and <code>Grant</code> CRs to create additional users and grants. Refer to the SQL resource documentation for further detail.</p>"},{"location":"BACKUP/#lock-tables","title":"<code>LOCK TABLES</code>","text":"<p>Galera is not compatible with the <code>LOCK TABLES</code> statement: - https://mariadb.com/kb/en/lock-tables/#limitations</p> <p>For this reason, the operator automatically adds the <code>--skip-add-locks</code> option to the <code>Backup</code> to overcome this limitation.</p>"},{"location":"BACKUP/#logical-backups","title":"Logical backups","text":"<p>Logical backups serve not just as a source of restoration, but also enable data mobility between <code>MariaDB</code> instances. These backups are called \"logical\" because they are independent from the <code>MariaDB</code> topology, as they only contain DDLs and <code>INSERT</code> statements to populate data.</p> <p>As of today, <code>mariadb-operator</code> only supports logical backups, but we have plans to implement Point-In-Time-Recovery(PITR) based on physical backups and binary logs. This will allow to restore the state of a <code>MariaDB</code> instance in a particular point in time, minimizing the RPO (data loss) and RTO (time to recover). See https://github.com/mariadb-operator/mariadb-operator/issues/507.</p>"},{"location":"BACKUP/#migrating-an-external-mariadb-to-a-mariadb-running-in-kubernetes","title":"Migrating an external MariaDB to a <code>MariaDB</code> running in Kubernetes","text":"<p>You can leverage logical backups to bring your external MariaDB data into a new <code>MariaDB</code> instance running in Kubernetes. Follow this runbook for doing so:</p> <ol> <li>Take a logical backup of your external MariaDB using one of the commands below:</li> </ol> <pre><code>mariadb-dump --user=${MARIADB_USER} --password=${MARIADB_PASSWORD} --host=${MARIADB_HOST} --single-transaction --events --routines --all-databases &gt; backup.2024-08-26T12:24:34Z.sql\n</code></pre> <p>[!IMPORTANT] If you are using Galera or planning to migrate to a Galera instance, make sure you understand the Galera backup limitations and use the following command instead:</p> <pre><code>mariadb-dump --user=${MARIADB_USER} --password=${MARIADB_PASSWORD} --host=${MARIADB_HOST} --single-transaction --events --routines --all-databases --skip-add-locks --ignore-table=mysql.global_priv &gt; backup.2024-08-26T12:24:34Z.sql\n</code></pre> <ol> <li> <p>Ensure that your backup file is named in the following format: <code>backup.2024-08-26T12:24:34Z.sql</code>. If the file name does not follow this format, it will be ignored by the operator.</p> </li> <li> <p>Upload the backup file to one of the supported storage types. We recommend using S3.</p> </li> <li> <p>Create your <code>MariaDB</code> resource declaring that you want to bootstrap from the previous backup and providing a root password <code>Secret</code> that matches the backup:</p> </li> </ol> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  rootPasswordSecretKeyRef:\n    name: mariadb\n    key: root-password\n  replicas: 3\n  galera:\n    enabled: true\n  storage:\n    size: 1Gi\n  bootstrapFrom:\n    s3:\n      bucket: backups\n      prefix: mariadb\n      endpoint: minio.minio.svc.cluster.local:9000\n      accessKeyIdSecretKeyRef:\n        name: minio\n        key: access-key-id\n      secretAccessKeySecretKeyRef:\n        name: minio\n        key: secret-access-key\n      tls:\n        enabled: true\n        caSecretKeyRef:\n          name: minio-ca\n          key: ca.crt\n    targetRecoveryTime: 2024-08-26T12:24:34Z\n</code></pre> <ol> <li>If you are using Galera in your new instance, migrate your previous users and grants to use the <code>User</code> and <code>Grant</code> CRs. Refer to the SQL resource documentation for further detail.</li> </ol>"},{"location":"BACKUP/#migrating-to-a-mariadb-with-different-topology","title":"Migrating to a <code>MariaDB</code> with different topology","text":"<p>Databa mobility between <code>MariaDB</code> instances with different topologies is possible with logical backups. However, there are a couple of technical details that you need to be aware of in the following scenarios:</p>"},{"location":"BACKUP/#migrating-between-standalone-and-replicated-mariadbs","title":"Migrating between standalone and replicated <code>MariaDBs</code>","text":"<p>This should be fully compatible, no issues have been detected.</p>"},{"location":"BACKUP/#migrating-from-standalonereplicated-to-galera-mariadbs","title":"Migrating from standalone/replicated to Galera <code>MariaDBs</code>","text":"<p>There are a couple of limitations regarding the backups in Galera, please make sure you read the Galera backup limitations section before proceeding.</p> <p>To overcome this limitations, the <code>Backup</code> in the standalone/replicated instance needs to be taken with <code>spec.ignoreGlobalPriv=true</code>. In the following example, we are backing up a standalone <code>MariaDB</code> (single instance):</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup-standalone\nspec:\n  mariaDbRef:\n    name: mariadb-standalone\n  ignoreGlobalPriv: true\n</code></pre> <p>Once the previous <code>Backup</code> is completed, we will be able bootstrap a new Galera instance from it:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  replicas: 3\n  galera:\n    enabled: true\n  storage:\n    size: 1Gi\n  bootstrapFrom:\n    backupRef:\n      name: backup-standalone\n</code></pre>"},{"location":"BACKUP/#minio-reference-installation","title":"Minio reference installation","text":"<p>The easiest way to get a S3 compatible storage is Minio. You can install it by using their helm chart, or, if you are looking for a production-grade deployment, take a look at their operator.</p> <p>In our case, we have have configured a Minio instance for development purposes, you can easily install it by running:</p> <pre><code>make cluster\nmake install-minio\nmake net # to access the console via a MetalLB LoadBalancer: https://minio-console:9001\n</code></pre> <p>As an alternative, you can also use play.min.io using these credentials.</p>"},{"location":"BACKUP/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> <li><code>mariadb-dump</code> options</li> <li><code>mariadb</code> options</li> </ul>"},{"location":"BACKUP/#troubleshooting","title":"Troubleshooting","text":""},{"location":"BACKUP/#galera-pods-restarting-after-bootstrapping-from-a-backup","title":"Galera <code>Pods</code> restarting after bootstrapping from a backup","text":"<p>Please make sure you understand the Galera backup limitations.</p> <p>After doing so, ensure that your backup does not contain a <code>DROP TABLE mysql.global_priv;</code> statement, as it will make your liveness and readiness probes to fail after the backup restoration.</p>"},{"location":"CONFIGURATION/","title":"Configuration","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.28</p> <p>This documentation aims to provide guidance on various configuration aspects across many <code>mariadb-operator</code> CRs. </p>"},{"location":"CONFIGURATION/#table-of-contents","title":"Table of contents","text":"<ul> <li>my.cnf</li> <li>Timezones</li> <li>Passwords</li> <li>External resources</li> <li>Probes</li> </ul>"},{"location":"CONFIGURATION/#mycnf","title":"my.cnf","text":"<p>An inline configuration file (my.cnf) can be provisioned in the <code>MariaDB</code> resource via the <code>myCnf</code> field:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n  myCnf: |\n    [mariadb]\n    bind-address=*\n    default_storage_engine=InnoDB\n    binlog_format=row\n    innodb_autoinc_lock_mode=2\n    innodb_buffer_pool_size=1024M\n    max_allowed_packet=256M \n</code></pre> <p>In this field, you may provide any configuration option or system variable supported by MariaDB.</p> <p>Under the hood, the operator automatically creates a <code>ConfigMap</code> with the contents of  the <code>myCnf</code> field, which will be mounted in the <code>MariaDB</code> instance. Alternatively, you can manage your own configuration using a pre-existing <code>ConfigMap</code> by linking it via <code>myCnfConfigMapKeyRef</code>. It is important to note that the key in this <code>ConfigMap</code> i.e. the config file name, must have a <code>.cnf</code> extension in order to be detected by MariaDB:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n  myCnfConfigMapKeyRef:\n    name: mariadb\n    key: mycnf\n</code></pre> <p>To ensure your configuration changes take effect, the operator triggers a rolling update whenever the <code>myCnf</code> field or a <code>ConfigMap</code> is updated. For the operator to detect changes in a <code>ConfigMap</code>, it must be labeled with <code>k8s.mariadb.com/watch</code>. Refer to the external resources section for further detail.</p>"},{"location":"CONFIGURATION/#timezones","title":"Timezones","text":"<p>By default, MariaDB does not load timezone data on startup for performance reasons and defaults the timezone to <code>SYSTEM</code>, obtaining the timezone information from the environment where it runs. See the MariaDB docs for further information.</p> <p>You can explicitly configure a timezone in your <code>MariaDB</code> instance by setting the <code>timeZone</code> field: </p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  timeZone: \"UTC\"\n</code></pre> <p>This setting is immutable and implies loading the timezone data on startup.</p> <p>In regards to <code>Backup</code> and <code>SqlJob</code> resources, which get reconciled into <code>CronJobs</code>, you can also define a <code>timeZone</code> associated with their cron expression:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup-scheduled\nspec:\n  mariaDbRef:\n    name: mariadb\n  schedule:\n    cron: \"*/1 * * * *\"\n    suspend: false\n  timeZone: \"UTC\"\n</code></pre> <p>If <code>timeZone</code> is not provided, the local timezone will be used, as described in the Kubernetes docs.</p>"},{"location":"CONFIGURATION/#passwords","title":"Passwords","text":"<p>Some CRs require passwords provided as <code>Secret</code> references to function properly. For instance, the root password for a <code>MariaDB</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  rootPasswordSecretKeyRef:\n    name: mariadb\n    key: root-password\n</code></pre> <p>By default, fields like <code>rootPasswordSecretKeyRef</code> are optional and defaulted by the operator, resulting in random password generation if not provided:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  rootPasswordSecretKeyRef:\n    name: mariadb\n    key: root-password\n    generate: true\n</code></pre> <p>You may choose to explicitly provide a <code>Secret</code> reference via <code>rootPasswordSecretKeyRef</code> and opt-out from random password generation by either not providing the <code>generate</code> field or setting it to <code>false</code>: </p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  rootPasswordSecretKeyRef:\n    name: mariadb\n    key: root-password\n    generate: false\n</code></pre> <p>This way, we are telling the operator that we are expecting a <code>Secret</code> to be available eventually, enabling the use of GitOps tools to seed the password: - sealed-secrets: The <code>Secret</code> is reconciled from a <code>SealedSecret</code>, which is decrypted by the sealed-secrets controller. - external-secrets: The <code>Secret</code> is reconciled fom an <code>ExternalSecret</code>, which is read by the external-secrets controller from an external secrets source (Vault, AWS Secrets Manager ...).</p>"},{"location":"CONFIGURATION/#external-resources","title":"External resources","text":"<p>Many CRs have a references to external resources (i.e. <code>ConfigMap</code>, <code>Secret</code>) not managed by the operator. </p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n  myCnfConfigMapKeyRef:\n    name: mariadb\n    key: mycnf\n</code></pre> <p>These external resources should be labeled with <code>k8s.mariadb.com/watch</code> so the operator can watch them and perform reconciliations based on their changes. For example, see the <code>my.cnf</code> <code>ConfigMap</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: mariadb\n  labels:\n    k8s.mariadb.com/watch: \"\"\ndata:\n  my.cnf: |\n    [mariadb]\n    bind-address=*\n    default_storage_engine=InnoDB\n    binlog_format=row\n    innodb_autoinc_lock_mode=2\n    innodb_buffer_pool_size=1024M\n    max_allowed_packet=256M\n</code></pre>"},{"location":"CONFIGURATION/#probes","title":"Probes","text":"<p>Kubernetes probes serve as an inversion of control mechanism, enabling the application to communicate its health status to Kubernetes. This enables Kubernetes to take appropriate actions when the application is unhealthy, such as restarting or stop sending traffic to <code>Pods</code>.</p> <p>[!IMPORTANT] Make sure you check the Kubernetes documentation if you are unfamiliar with Kubernetes probes.</p> <p>Fine tunning of probes for databases running in Kubernetes is critical, you may do so by tweaking the following fields:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  livenessProbe:\n    initialDelaySeconds: 20\n    periodSeconds: 5\n    timeoutSeconds: 5\n\n  readinessProbe:\n    initialDelaySeconds: 20\n    periodSeconds: 5\n    timeoutSeconds: 5\n</code></pre> <p>There isn't an universally correct default value for these thresholds, so we recommend determining your own based on factors like the compute resources, network, storage, and other aspects of the environment where your <code>MariaDB</code> and <code>MaxScale</code> instances are running.</p>"},{"location":"DEVELOPMENT/","title":"Development guide","text":"<p>In this guide, we will be configuring a local environment to run <code>mariadb-operator</code> so you can develop and test features without hassle. The local <code>mariadb-operator</code> will be able to resolve DNS and connect to MariaDB as if it was running inside a Kubernetes cluster.</p>"},{"location":"DEVELOPMENT/#table-of-contents","title":"Table of contents","text":"<ul> <li>Flavours</li> <li>Getting started</li> <li>Cluster</li> <li>Network</li> <li>Dependencies</li> <li>Generate</li> <li>Install</li> <li>Build</li> <li>Run</li> <li>Test</li> </ul>"},{"location":"DEVELOPMENT/#flavours","title":"Flavours","text":""},{"location":"DEVELOPMENT/#devcontainer","title":"devcontainer","text":"<p>Spin up a devcontainer with everything you need to develop. This can be used in conjunction with many tools, such as vscode, GitHub codespaces and DevPod, which will automatically detect the devcontainer.json.</p> <p>The only dependency you need is docker in case that choose to run your devcontainer locally.</p>"},{"location":"DEVELOPMENT/#local","title":"local","text":"<p>Run the operator locally in your machine using <code>go run</code>. It requires the following dependencies: - make - go - docker</p> <p>This flavour uses KIND and MetalLB under the hood to provision Kubernetes clusters and assign local IPs to <code>LoadBalancer</code> <code>Services</code>. It has some limitations in Mac and Windows which will make the operator unable to connect to MariaDB via the <code>LoadBalancer</code> <code>Service</code>, leading to errors when reconciling SQL-related resources. Alternatively, use the devcontainer flavour.</p>"},{"location":"DEVELOPMENT/#getting-started","title":"Getting started","text":"<p>After having decided which flavour to use and install the required dependencies, you will be able to use the <code>Makefile</code> targets we provide. For convenience, every development action has an associated <code>Makefile</code> target. You can list all of them by running <code>make</code>:</p> <pre><code>make\n\nUsage:\n  make &lt;target&gt;\n\nGeneral\n  help             Display this help.\n\n...\n\nInstall\n  install-crds     Install CRDs.\n  uninstall-crds   Uninstall CRDs.\n  install          Install CRDs and dependencies for local development.\n  install-samples  Install sample configuration.\n  serviceaccount   Create long-lived ServiceAccount token for development.\n\nDev\n  certs            Generates development certificates.\n  lint             Lint.\n  build            Build binary.\n  test             Run tests.\n  cover            Run tests and generate coverage.\n  release          Test release locally.\n\nOperator\n  run              Run a controller from your host. \n\n...\n</code></pre>"},{"location":"DEVELOPMENT/#cluster","title":"Cluster","text":"<p>To start with, you will need a Kubernetes cluster for developing locally. You can provision a KIND cluster by using the following target:</p> <pre><code>make cluster\n</code></pre> <p>To decommission the cluster:</p> <pre><code>make cluster-delete\n</code></pre>"},{"location":"DEVELOPMENT/#network","title":"Network","text":"<p>You can configure the network connectivity so the operator is able to resolve DNS and address MariaDB as if it was running in-cluster:</p> <pre><code>make net\n</code></pre> <p>This connectivity leverages MetalLB to assign local IPs to the <code>LoadBalancer</code> <code>Services</code> for the operator to connect to MariaDB. For this to happen, these local IPs need to be within the docker CIDR, which can be queried using:</p> <pre><code>make cidr\n172.18.0.0/16\n</code></pre> <p>When deploying example manifests, take into account that <code>LoadBalancer</code> <code>Services</code> need to be within the docker CIDR to function properly, see: - examples/manifests/mariadb_v1alpha1_mariadb.yaml - examples/manifests/mariadb_v1alpha1_mariadb_replication.yaml - examples/manifests/mariadb_v1alpha1_mariadb_galera.yaml</p>"},{"location":"DEVELOPMENT/#dependencies","title":"Dependencies","text":"<p>You might need the following third party dependencies to test certain features of <code>mariadb-operator</code>, to install them run:</p> <pre><code>make install-prometheus\nmake install-cert-manager\nmake install-minio\n</code></pre> <p>Some of this dependencies have ports mapped to the host (i.e. Grafana and Minio to expose the dashboard) so be sure to check the forwarded ports to access. This step requires running <code>make net</code> previously.</p>"},{"location":"DEVELOPMENT/#generate","title":"Generate","text":"<p>This target generates code, CRDs and deployment manifests. Make sure to run this before pushing a commit, as it is required by the CI:</p> <pre><code>make gen\n</code></pre>"},{"location":"DEVELOPMENT/#install","title":"Install","text":"<p>Install CRDs and everything you need to run the operator locally:</p> <pre><code>make install\n</code></pre>"},{"location":"DEVELOPMENT/#build","title":"Build","text":"<p>Build the operator binary:</p> <pre><code>make build\n</code></pre> <p>Build the docker image and load it into KIND:</p> <pre><code>make docker-build\nmake docker-load\n</code></pre>"},{"location":"DEVELOPMENT/#run","title":"Run","text":"<pre><code>make cluster\nmake install\nmake net\nmake run\n</code></pre>"},{"location":"DEVELOPMENT/#unit-tests","title":"Unit tests","text":"<pre><code>make test\n</code></pre>"},{"location":"DEVELOPMENT/#integration-tests","title":"Integration tests","text":"<pre><code>make cluster\nmake install\nmake install-minio\nmake net\nmake test-int\n</code></pre>"},{"location":"DOCKER/","title":"Docker Images for MariaDB Operator","text":"<p>The mariadb-operator uses a variety of docker images depending on how it\u2019s configured and what mix of open source or commercial software you\u2019d like to use. As only the latest version of MariaDB Community Server is supported, the community server version will increment frequently with only a best effort made to keep current with the latest release(s). Only MariaDB Enterprise Server offers support for older versions.</p> <p>[!NOTE] Using Docker images other than the supported ones in this document is not recommended at this time.</p> Component Docker Registry Supported Tags CPU Pull Command MariaDB Community Server Public <code>11.4.3</code> (Used with Community Operator)<code>11.4.3-ubi9</code> (Used with Enterprise Operator) <code>amd64</code> <code>arm64</code> <code>ppc64le</code> <code>s390x</code> <code>docker pull docker-registry1.mariadb.com/library/mariadb:11.4.3</code><code>docker pull docker-registry1.mariadb.com/library/mariadb:11.4.3-ubi9</code> MariaDB Enterprise Server Privatedocker.mariadb.comLogin required, click link for instructions <code>10.6.18-14.1</code> <code>10.6.17-13.1</code> <code>10.5.25-19.1</code> <code>10.5.24-18.1</code> <code>amd64</code> <code>arm64</code> <code>docker pull docker-registry.mariadb.com/enterprise-server:10.6.18-14</code> MariaDB MaxScale UBI Public <code>23.08.6-ubi-1</code> <code>24.02.2-ubi-1</code> <code>amd64</code> <code>arm64</code> <code>docker pull docker-registry2.mariadb.com/mariadb/maxscale:23.08.6-ubi-1</code> MariaDB MaxScale Rocky Linux Public <code>mariadb/maxscale:23.08.5</code> <code>amd64</code> <code>arm64</code> <code>docker pull docker-registry2.mariadb.com/mariadb/maxscale:23.08.5</code> MariaDB Prometheus Exporter Public <code>v0.0.1</code> <code>amd64</code> <code>arm64</code> <code>docker pull docker-registry2.mariadb.com/mariadb/mariadb-prometheus-exporter-ubi:v0.0.1</code> MariaDB MaxScale prometheus exporter Public <code>v0.0.1</code> <code>amd64</code> <code>arm64</code> <code>docker pull docker-registry2.mariadb.com/mariadb/maxscale-prometheus-exporter-ubi:v0.0.1</code> Community Operator Public <code>0.34.0</code> <code>amd64</code> <code>arm64</code> <code>docker pull docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:0.34.0</code> Enterprise Operator Public <code>0.34.0</code> <code>amd64</code> <code>arm64</code> <code>docker pull docker-registry2.mariadb.com/mariadb/mariadb-operator-enterprise:0.34.0</code>"},{"location":"GALERA/","title":"High availability via Galera","text":"<p>The <code>mariadb-operator</code> provides cloud native support for provisioning and operating multi-master MariaDB clusters using Galera. This setup enables the ability to perform both read and write operations on all nodes, enhancing availability and allowing scalability across multiple nodes.</p> <p>In certain circumstances, it could be the case that all the nodes of your cluster go down at the same time, something that Galera is not able to recover by itself, and it requires manual action to bring the cluster up again, as documented in the Galera documentation. Luckly enough, <code>mariadb-operator</code> has you covered and it encapsulates this operational expertise in the <code>MariaDB</code> CRD. You just need to declaratively specify <code>spec.galera</code>, as explained in more detail later in this guide.</p> <p>To accomplish this, after the MariaDB cluster has been provisioned, <code>mariadb-operator</code> will regularly monitor the cluster's status to make sure it is healthy. If any issues are detected, the operator will initiate the recovery process to restore the cluster to a healthy state. During this process, the operator will set status conditions in the <code>MariaDB</code> and emit <code>Events</code> so you have a better understanding of the recovery progress and the underlying activities being performed. For example, you may want to know which <code>Pods</code> were out of sync to further investigate infrastructure-related issues (i.e. networking, storage...) on the nodes where these <code>Pods</code> were scheduled.</p>"},{"location":"GALERA/#table-of-contents","title":"Table of contents","text":"<ul> <li>Data-plane</li> <li><code>MariaDB</code> configuration</li> <li>Storage</li> <li>Wsrep provider</li> <li>IPv6 support</li> <li>Agent auth methods</li> <li>Backup and restore</li> <li>Galera cluster recovery</li> <li>Bootstrap Galera cluster from existing PVCs</li> <li>Quickstart</li> <li>Troubleshooting</li> <li>Reference</li> </ul>"},{"location":"GALERA/#data-plane","title":"Data-plane","text":"<p>To be able to effectively provision and recover MariaDB Galera clusters, the following data-plane components were introduced to run alongside MariaDB and co-operate with <code>mariadb-operator</code>: - init: Init container that dynamically provisions the Galera configuration file before the MariaDB container starts. Guarantees ordered deployment of <code>Pods</code> even if <code>spec.podManagementPolicy=Parallel</code> is set on the MariaDB <code>StatefulSet</code>, something crucial for performing the Galera recovery, as the operator needs to restart <code>Pods</code> independently. - agent: Sidecar agent that exposes the Galera state (<code>grastate.dat</code>) via HTTP and allows the operator to remotely bootstrap and recover the Galera cluster. It comes with multiple auth methods to ensure that only the operator is able to call the agent.</p> <p>All these components are available in the operator image. More preciselly, they are subcommands of the CLI shipped as binary inside the image.</p>"},{"location":"GALERA/#mariadb-configuration","title":"<code>MariaDB</code> configuration","text":"<p>The easiest way to get a MariaDB Galera cluster up and running is setting <code>spec.galera.enabled = true</code>, like in this example:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n...\n  replicas: 3\n\n  galera:\n    enabled: true\n</code></pre> <p>This relies on sensible defaults set by the operator, which may not be suitable for your Kubernetes cluster. This can be solved by overriding the defaults, as in this other example, so you have fine-grained control over the Galera configuration.</p> <p>Refer to the reference section to better understand the purpose of each field.</p>"},{"location":"GALERA/#storage","title":"Storage","text":"<p>By default, <code>mariadb-operator</code> provisions two PVCs for running Galera: - Storage PVC: Used to back the MariaDB data directory, mounted at <code>/var/lib/mysql</code>. - Config PVC: Where the Galera config files are located, mounted at <code>/etc/mysql/conf.d</code>.</p> <p>However, you are also able to use just one PVC for keeping both the data and the config files:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  galera:\n    enabled: true\n    config:\n      reuseStorageVolume: true\n</code></pre>"},{"location":"GALERA/#wsrep-provider","title":"Wsrep provider","text":"<p>You are able to pass extra options to the Galera wsrep provider by using the <code>galera.providerOptions</code> field:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  galera:\n    providerOptions:\n      gcs.fc_limit: '64'\n</code></pre> <p>It is important to note that, the <code>ist.recv_addr</code> cannot be set by the user, as it is automatically configured to the <code>Pod</code> IP by the operator, something that an user won't be able to know beforehand.</p> <p>A list of the available options can be found in the MariaDB documentation.</p>"},{"location":"GALERA/#ipv6-support","title":"IPv6 support","text":"<p>If you have a Kubernetes cluster running with IPv6, the operator will automatically detect the IPv6 addresses of your <code>Pods</code> and it will configure several wsrep provider options to ensure that the Galera protocol runs smoothly with IPv6.</p>"},{"location":"GALERA/#agent-auth-methods","title":"Agent auth methods","text":"<p>As previously mentioned in the data-plane section, the agent exposes an API to remotely manage the MariaDB Galera cluster. The following authentication methods are supported to ensure that only the operator is able to call the agent:</p>"},{"location":"GALERA/#serviceaccount-based-authentication","title":"<code>ServiceAccount</code> based authentication","text":"<p>The operator uses its <code>ServiceAccount</code> token as a mean of  authentication for communicating with the agent, which subsequently verifies the token by creating a <code>TokenReview</code> object. This is the default authentication method and will be automatically applied by setting:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  galera:\n    agent:\n      kubernetesAuth:\n        enabled: true\n</code></pre> <p>This Kubernetes-native authentication mechanism eliminates the need for the operator to manage credentials, as it relies entirely on Kubernetes for this purpose. However, the drawback is that the agent requires cluster-wide permissions to impersonate the <code>system:auth-delegator</code> <code>ClusterRole</code> and to create <code>TokenReviews</code>, which are cluster-scoped objects.</p>"},{"location":"GALERA/#basic-authentication","title":"Basic authentication","text":"<p>As an alternative, the agent also supports basic authentication:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  galera:\n    agent:\n      basicAuth:\n        enabled: true\n</code></pre> <p>Unlike the <code>ServiceAccount</code> based authentication, the operator needs to explicitly generate credentials to authenticate. The advantage of this approach is that it is entirely decoupled from Kubernetes and it does not require cluster-wide permissions on the Kubernetes API.</p>"},{"location":"GALERA/#backup-and-restore","title":"Backup and restore","text":"<p>Please refer to the backup documentation to understand how to backup and restore Galera clusters. Specially, make sure you understand the Galera backup limitations.</p>"},{"location":"GALERA/#galera-cluster-recovery","title":"Galera cluster recovery","text":"<p><code>mariadb-operator</code> is able to monitor the Galera cluster and act accordinly to recover it if needed. This feature is enabled by default, but you may tune it as you need:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  galera:\n    enabled: true\n    recovery:\n      enabled: true\n      minClusterSize: 1\n      clusterMonitorInterval: 10s\n      clusterHealthyTimeout: 30s\n      clusterBootstrapTimeout: 10m\n      podRecoveryTimeout: 5m\n      podSyncTimeout: 5m\n</code></pre> <p>The <code>minClusterSize</code> field indicates the minimum cluster size (either absolut number of replicas or percentage) for the operator to consider the cluster healthy. If the cluster is unhealthy for more than the period defined in <code>clusterHealthyTimeout</code> (<code>30s</code> by default), a cluster recovery process is initiated by the operator. The process is explained in the Galera documentation and consists of the following steps:</p> <ul> <li>Recover the sequence number from the <code>grastate.dat</code> on each node.</li> <li>Trigger a recovery <code>Job</code> to obtain the sequence numbers in case that the previous step didn't manage to.</li> <li>Mark the node with highest sequence (bootstrap node) as safe to bootstrap.</li> <li>Bootstrap a new cluster in the bootstrap node.</li> <li>Restart and wait until the bootstrap node becomes ready.</li> <li>Restart the rest of the nodes one by one so they can join the new cluster.</li> </ul> <p>The operator monitors the Galera cluster health periodically and performs the cluster recovery described above if needed. You are able to tune the monitoring interval via the <code>clusterMonitorInterval</code> field.</p> <p>Refer to the reference section to better understand the purpose of each field.</p>"},{"location":"GALERA/#galera-recovery-job","title":"Galera recovery <code>Job</code>","text":"<p>During the recovery process, a <code>Job</code> is triggered for each <code>MariaDB</code> <code>Pod</code> to obtain the sequence numbers. It's crucial for this <code>Job</code> to succeed; otherwise, the recovery process will fail. As a user, you are responsible for adjusting this <code>Job</code> to allocate sufficient resources and provide the necessary metadata to ensure its successful completion.</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  galera:\n    enabled: true\n    recovery:\n      job:\n        metadata:\n          labels:\n            sidecar.istio.io/inject: \"false\"\n        resources:\n          requests:\n            cpu: 100m\n            memory: 128Mi\n          limits:\n            memory: 256Mi\n</code></pre> <p>For example, if you're using a service mesh like Istio, it's important to add the <code>sidecar.istio.io/inject=false</code> label. Without this label, the <code>Job</code> will not complete, which would prevent the recovery process from finishing successfully.</p>"},{"location":"GALERA/#force-cluster-bootstrap","title":"Force cluster bootstrap","text":"<p>[!CAUTION] Use this option only in exceptional circumstances. Not selecting the <code>Pod</code> with the highest sequence number may result in data loss.</p> <p>[!WARNING] Ensure you unset <code>forceClusterBootstrapInPod</code> after completing the bootstrap to allow the operator to choose the appropriate <code>Pod</code> to bootstrap from in an event of cluster recovery.</p> <p>You have the ability to manually select which <code>Pod</code> is used to bootstrap a new cluster during the recovery process by setting <code>forceClusterBootstrapInPod</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  galera:\n    enabled: true\n    recovery:\n      enabled: true\n      forceClusterBootstrapInPod: \"mariadb-galera-0\"\n</code></pre> <p>This should only be used in exceptional circumstances: - You are absolutely certain that the chosen <code>Pod</code> has the highest sequence number. - The operator has not yet selected a <code>Pod</code> to bootstrap from.</p> <p>You can verify this with the following command:</p> <pre><code>kubectl get mariadb mariadb-galera -o jsonpath=\"{.status.galeraRecovery}\" | jq\n{\n  \"recovered\": {\n    \"mariadb-galera-0\": {\n      \"seqno\": 350454,\n      \"uuid\": \"67a44ea9-63a8-11ef-98a2-2b0c0aa0a627\"\n    },\n    \"mariadb-galera-1\": {\n      \"seqno\": 350450,\n      \"uuid\": \"67a44ea9-63a8-11ef-98a2-2b0c0aa0a627\"\n    }\n  },\n  \"state\": {\n    \"mariadb-galera-0\": {\n      \"safeToBootstrap\": false,\n      \"seqno\": -1,\n      \"uuid\": \"67a44ea9-63a8-11ef-98a2-2b0c0aa0a627\",\n      \"version\": \"2.1\"\n    },\n    \"mariadb-galera-1\": {\n      \"safeToBootstrap\": false,\n      \"seqno\": -1,\n      \"uuid\": \"67a44ea9-63a8-11ef-98a2-2b0c0aa0a627\",\n      \"version\": \"2.1\"\n    },\n    \"mariadb-galera-2\": {\n      \"safeToBootstrap\": false,\n      \"seqno\": -1,\n      \"uuid\": \"67a44ea9-63a8-11ef-98a2-2b0c0aa0a627\",\n      \"version\": \"2.1\"\n    }\n  }\n}\n</code></pre> <p>In this case, assuming that <code>mariadb-galera-2</code> sequence is lower than <code>350454</code>, it should be safe to bootstrap from <code>mariadb-galera-0</code>.</p> <p>Finally, after your cluster has been bootstrapped, remember to unset <code>forceClusterBootstrapInPod</code> to allow the operator to select the appropriate node for bootstrapping in the event of a cluster recovery.</p>"},{"location":"GALERA/#bootstrap-galera-cluster-from-existing-pvcs","title":"Bootstrap Galera cluster from existing PVCs","text":"<p><code>mariadb-operator</code> will never delete your <code>MariaDB</code> PVCs. Whenever you delete a <code>MariaDB</code> resource, the PVCs will remain intact so you could reuse them to re-provision a new cluster.</p> <p>That said, Galera is unable to form a cluster from pre-existing state, it requires a cluster recovery process to identify which <code>Pod</code> has the highest sequence number to bootstrap a new cluster. That's exactly what the operator does: whenever a new <code>MariaDB</code> Galera cluster is created and previously created PVCs exist, a cluster recovery process is automatically triggered.</p>"},{"location":"GALERA/#quickstart","title":"Quickstart","text":"<p>First of all, install the following configuration manifests that will be referenced by the CRDs further:</p> <pre><code>kubectl apply -f examples/manifests/config\n</code></pre> <p>Next, you can proceed with the installation of a <code>MariaDB</code> instance with Galera support:</p> <pre><code>kubectl apply -f examples/manifests/mariadb_galera.yaml\n</code></pre> <pre><code>kubectl get mariadbs\nNAME             READY   STATUS    PRIMARY POD          AGE\nmariadb-galera   True    Running   mariadb-galera-0     48m\n\nkubectl get events --field-selector involvedObject.name=mariadb-galera --sort-by='.lastTimestamp'\nLAST SEEN   TYPE     REASON                 OBJECT                               MESSAGE\n...\n45m         Normal   GaleraClusterHealthy   mariadb/mariadb-galera               Galera cluster is healthy\n\nkubectl get mariadb mariadb-galera -o jsonpath=\"{.status.conditions[?(@.type=='GaleraReady')]}\"\n{\"lastTransitionTime\":\"2023-07-13T18:22:31Z\",\"message\":\"Galera ready\",\"reason\":\"GaleraReady\",\"status\":\"True\",\"type\":\"GaleraReady\"}\n\nkubectl get mariadb mariadb-galera -o jsonpath=\"{.status.conditions[?(@.type=='GaleraConfigured')]}\"\n{\"lastTransitionTime\":\"2023-07-13T18:22:31Z\",\"message\":\"Galera configured\",\"reason\":\"GaleraConfigured\",\"status\":\"True\",\"type\":\"GaleraConfigured\"}\n\nkubectl get statefulsets -o wide\nNAME             READY   AGE   CONTAINERS      IMAGES\nmariadb-galera   3/3     58m   mariadb,agent   mariadb:11.0.3,ghcr.io/mariadb-operator/mariadb-operator:v0.0.26\n\nkubectl get pods -o wide\nNAME                                        READY   STATUS    RESTARTS   AGE   IP           NODE          NOMINATED NODE   READINESS GATES\nmariadb-galera-0                            2/2     Running   0          58m   10.244.2.4   mdb-worker3   &lt;none&gt;           &lt;none&gt;\nmariadb-galera-1                            2/2     Running   0          58m   10.244.1.9   mdb-worker2   &lt;none&gt;           &lt;none&gt;\nmariadb-galera-2                            2/2     Running   0          58m   10.244.5.4   mdb-worker4   &lt;none&gt;           &lt;none&gt;\n</code></pre> <p>Up and running. Let's now proceed with simulating a Galera cluster failure by deleting all the <code>Pods</code> at the same time:</p> <pre><code>kubectl delete pods -l app.kubernetes.io/instance=mariadb-galera\npod \"mariadb-galera-0\" deleted\npod \"mariadb-galera-1\" deleted\npod \"mariadb-galera-2\" deleted\n</code></pre> <p>After some time, we will see the <code>MariaDB</code> entering a non <code>Ready</code> state:</p> <pre><code>kubectl get mariadb mariadb-galera\nNAME             READY   STATUS             PRIMARY POD             AGE\nmariadb-galera   False   Galera not ready   mariadb-galera-0        67m\n\nkubectl get events --field-selector involvedObject.name=mariadb-galera --sort-by='.lastTimestamp'\nLAST SEEN   TYPE      REASON                    OBJECT                       MESSAGE\n...\n48s         Warning   GaleraClusterNotHealthy   mariadb/mariadb-galera       Galera cluster is not healthy\n\nkubectl get mariadb mariadb-galera -o jsonpath=\"{.status.conditions[?(@.type=='GaleraReady')]}\"\n{\"lastTransitionTime\":\"2023-07-13T19:25:17Z\",\"message\":\"Galera not ready\",\"reason\":\"GaleraNotReady\",\"status\":\"False\",\"type\":\"GaleraReady\"}\n</code></pre> <p>Eventually, the operator will kick in and recover the Galera cluster:</p> <pre><code>kubectl get events --field-selector involvedObject.name=mariadb-galera --sort-by='.lastTimestamp'\nLAST SEEN   TYPE      REASON                    OBJECT                       MESSAGE\n...\n16m         Warning   GaleraClusterNotHealthy   mariadb/mariadb-galera       Galera cluster is not healthy\n16m         Normal    GaleraPodStateFetched     mariadb/mariadb-galera       Galera state fetched in Pod 'mariadb-galera-2'\n16m         Normal    GaleraPodStateFetched     mariadb/mariadb-galera       Galera state fetched in Pod 'mariadb-galera-1'\n16m         Normal    GaleraPodStateFetched     mariadb/mariadb-galera       Galera state fetched in Pod 'mariadb-galera-0'\n16m         Normal    GaleraPodRecovered        mariadb/mariadb-galera       Recovered Galera sequence in Pod 'mariadb-galera-1'\n16m         Normal    GaleraPodRecovered        mariadb/mariadb-galera       Recovered Galera sequence in Pod 'mariadb-galera-2'\n17m         Normal    GaleraPodRecovered        mariadb/mariadb-galera       Recovered Galera sequence in Pod 'mariadb-galera-0'\n17m         Normal    GaleraClusterBootstrap    mariadb/mariadb-galera       Bootstrapping Galera cluster in Pod 'mariadb-galera-2'\n20m         Normal    GaleraClusterHealthy      mariadb/mariadb-galera       Galera cluster is healthy\n\nkubectl get mariadb mariadb-galera -o jsonpath=\"{.status.galeraRecovery}\"\n{\"bootstrap\":{\"pod\":\"mariadb-galera-2\",\"time\":\"2023-07-13T19:25:28Z\"},\"recovered\":{\"mariadb-galera-0\":{\"seqno\":3,\"uuid\":\"bf00b9c3-21a9-11ee-984f-9ba9ff0e9285\"},\"mariadb-galera-1\":{\"seqno\":3,\"uuid\":\"bf00b9c3-21a9-11ee-984f-9ba9ff0e9285\"},\"mariadb-galera-2\":{\"seqno\":3,\"uuid\":\"bf00b9c3-21a9-11ee-984f-9ba9ff0e9285\"}},\"state\":{\"mariadb-galera-0\":{\"safeToBootstrap\":false,\"seqno\":-1,\"uuid\":\"bf00b9c3-21a9-11ee-984f-9ba9ff0e9285\",\"version\":\"2.1\"},\"mariadb-galera-1\":{\"safeToBootstrap\":false,\"seqno\":-1,\"uuid\":\"bf00b9c3-21a9-11ee-984f-9ba9ff0e9285\",\"version\":\"2.1\"},\"mariadb-galera-2\":{\"safeToBootstrap\":false,\"seqno\":-1,\"uuid\":\"bf00b9c3-21a9-11ee-984f-9ba9ff0e9285\",\"version\":\"2.1\"}}}\n</code></pre> <p>Finally, the <code>MariaDB</code> resource will become <code>Ready</code> and your Galera cluster will be operational again:</p> <pre><code>kubectl get mariadb mariadb-galera -o jsonpath=\"{.status.conditions[?(@.type=='GaleraReady')]}\"\n{\"lastTransitionTime\":\"2023-07-13T19:27:51Z\",\"message\":\"Galera ready\",\"reason\":\"GaleraReady\",\"status\":\"True\",\"type\":\"GaleraReady\"}\n\nkubectl get mariadb mariadb-galera\nNAME             READY   STATUS    PRIMARY POD          AGE\nmariadb-galera   True    Running   mariadb-galera-0     82m\n</code></pre>"},{"location":"GALERA/#troubleshooting","title":"Troubleshooting","text":"<p>The aim of this section is showing you how to diagnose your Galera cluster when something goes wrong. In this situations, observability is a key factor to understand the problem, so we recommend following these steps before jumping into debugging the problem.</p> <ul> <li>Inspect <code>MariaDB</code> status conditions.</li> </ul> <pre><code>kubectl get mariadb mariadb-galera -o jsonpath=\"{.status}\"\n{\"conditions\":[{\"lastTransitionTime\":\"2023-08-05T14:58:57Z\",\"message\":\"Galera not ready\",\"reason\":\"GaleraNotReady\",\"status\":\"False\",\"type\":\"Ready\"},{\"lastTransitionTime\":\"2023-08-05T14:58:57Z\",\"message\":\"Galera not ready\",\"reason\":\"GaleraNotReady\",\"status\":\"False\",\"type\":\"GaleraReady\"},{\"lastTransitionTime\":\"2023-08-03T19:21:16Z\",\"message\":\"Galera configured\",\"reason\":\"GaleraConfigured\",\"status\":\"True\",\"type\":\"GaleraConfigured\"}],\"currentPrimary\":\"All\",\"galeraRecovery\":{\"bootstrap\":{\"pod\":\"mariadb-galera-1\",\"time\":\"2023-08-05T14:59:18Z\"},\"recovered\":{\"mariadb-galera-0\":{\"seqno\":17,\"uuid\":\"6ea235ec-3232-11ee-8152-4af03d2c43a9\"},\"mariadb-galera-1\":{\"seqno\":17,\"uuid\":\"6ea235ec-3232-11ee-8152-4af03d2c43a9\"},\"mariadb-galera-2\":{\"seqno\":16,\"uuid\":\"6ea235ec-3232-11ee-8152-4af03d2c43a9\"}},\"state\":{\"mariadb-galera-0\":{\"safeToBootstrap\":false,\"seqno\":-1,\"uuid\":\"6ea235ec-3232-11ee-8152-4af03d2c43a9\",\"version\":\"2.1\"},\"mariadb-galera-1\":{\"safeToBootstrap\":false,\"seqno\":-1,\"uuid\":\"6ea235ec-3232-11ee-8152-4af03d2c43a9\",\"version\":\"2.1\"},\"mariadb-galera-2\":{\"safeToBootstrap\":false,\"seqno\":-1,\"uuid\":\"6ea235ec-3232-11ee-8152-4af03d2c43a9\",\"version\":\"2.1\"}}}}\n</code></pre> <ul> <li>Make sure network connectivity is fine by checking that you have an <code>Endpoint</code> per <code>Pod</code> in your Galera cluster.</li> </ul> <pre><code>kubectl get endpoints mariadb-galera-internal -o yaml\napiVersion: v1\nkind: Endpoints\nmetadata:\n  name: mariadb-internal\nsubsets:\n- addresses:\n  - hostname: mariadb-1\n    ip: 10.255.140.181\n    nodeName: k8s-worker-1\n    targetRef:\n      kind: Pod\n      name: mariadb-1\n      namespace: mariadb\n  - hostname: mariadb-2\n    ip: 10.255.20.156\n    nodeName: k8s-worker-2\n    targetRef:\n      kind: Pod\n      name: mariadb-2\n      namespace: mariadb\n  - hostname: mariadb-0\n    ip: 10.255.214.164\n    nodeName: k8s-worker-0\n    targetRef:\n      kind: Pod\n      name: mariadb-0\n      namespace: mariadb\n  ports:\n  - name: sst\n    port: 4568\n    protocol: TCP\n  - name: ist\n    port: 4567\n    protocol: TCP\n  - name: mariadb\n    port: 3306\n    protocol: TCP\n  - name: agent\n    port: 5555\n    protocol: TCP\n  - name: cluster\n    port: 4444\n    protocol: TCP\n\n</code></pre> <ul> <li>Check the events associated with the <code>MariaDB</code> object, as they provide significant insights for diagnosis, particularly within the context of cluster recovery.</li> </ul> <pre><code>kubectl get events --field-selector involvedObject.name=mariadb-galera --sort-by='.lastTimestamp'\nLAST SEEN   TYPE      REASON                    OBJECT                       MESSAGE\n...\n16m         Warning   GaleraClusterNotHealthy   mariadb/mariadb-galera       Galera cluster is not healthy\n16m         Normal    GaleraPodStateFetched     mariadb/mariadb-galera       Galera state fetched in Pod 'mariadb-galera-2'\n16m         Normal    GaleraPodStateFetched     mariadb/mariadb-galera       Galera state fetched in Pod 'mariadb-galera-1'\n16m         Normal    GaleraPodStateFetched     mariadb/mariadb-galera       Galera state fetched in Pod 'mariadb-galera-0'\n16m         Normal    GaleraPodRecovered        mariadb/mariadb-galera       Recovered Galera sequence in Pod 'mariadb-galera-1'\n16m         Normal    GaleraPodRecovered        mariadb/mariadb-galera       Recovered Galera sequence in Pod 'mariadb-galera-2'\n17m         Normal    GaleraPodRecovered        mariadb/mariadb-galera       Recovered Galera sequence in Pod 'mariadb-galera-0'\n17m         Normal    GaleraClusterBootstrap    mariadb/mariadb-galera       Bootstrapping Galera cluster in Pod 'mariadb-galera-2'\n20m         Normal    GaleraClusterHealthy      mariadb/mariadb-galera       Galera cluster is healthy\n</code></pre> <ul> <li>Enable <code>debug</code> logs in <code>mariadb-operator</code>.</li> </ul> <pre><code>helm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --set logLevel=debug\nkubectl logs mariadb-operator-546c78f4f5-gq44k\n{\"level\":\"info\",\"ts\":1691090524.4911606,\"logger\":\"galera.health\",\"msg\":\"Checking Galera cluster health\",\"controller\":\"statefulset\",\"controllerGroup\":\"apps\",\"controllerKind\":\"StatefulSet\",\"statefulSet\":{\"name\":\"mariadb-galera\",\"namespace\":\"default\"},\"namespace\":\"default\",\"name\":\"mariadb-galera\",\"reconcileID\":\"098620db-4486-45cc-966a-9f3fec0d165e\"}\n{\"level\":\"debug\",\"ts\":1691090524.4911761,\"logger\":\"galera.health\",\"msg\":\"StatefulSet ready replicas\",\"controller\":\"statefulset\",\"controllerGroup\":\"apps\",\"controllerKind\":\"StatefulSet\",\"statefulSet\":{\"name\":\"mariadb-galera\",\"namespace\":\"default\"},\"namespace\":\"default\",\"name\":\"mariadb-galera\",\"reconcileID\":\"098620db-4486-45cc-966a-9f3fec0d165e\",\"replicas\":1}\n</code></pre> <ul> <li>Get the logs of all the <code>MariaDB</code> <code>Pod</code> containers, not only of the main <code>mariadb</code> container but also the <code>agent</code> and <code>init</code> ones.</li> </ul> <pre><code>kubectl logs mariadb-galera-0 -c init\n{\"level\":\"info\",\"ts\":1691090778.5239124,\"msg\":\"Starting init\"}\n{\"level\":\"info\",\"ts\":1691090778.5305626,\"msg\":\"Configuring Galera\"}\n{\"level\":\"info\",\"ts\":1691090778.5307593,\"msg\":\"Already initialized. Init done\"}\n\nkubectl logs mariadb-galera-0 -c agent\n{\"level\":\"info\",\"ts\":1691090779.3193653,\"logger\":\"server\",\"msg\":\"server listening\",\"addr\":\":5555\"}\n2023/08/03 19:26:28 \"POST http://mariadb-galera-0.mariadb-galera-internal.default.svc.cluster.local:5555/api/recovery HTTP/1.1\" from 10.244.4.2:39162 - 200 58B in 4.112086ms\n2023/08/03 19:26:28 \"DELETE http://mariadb-galera-0.mariadb-galera-internal.default.svc.cluster.local:5555/api/recovery HTTP/1.1\" from 10.244.4.2:39162 - 200 0B in 883.544\u00b5s\n\nkubectl logs mariadb-galera-0 -c mariadb\n2023-08-03 19:27:10 0 [Note] WSREP: Member 2.0 (mariadb-galera-0) synced with group.\n2023-08-03 19:27:10 0 [Note] WSREP: Processing event queue:...100.0% (1/1 events) complete.\n2023-08-03 19:27:10 0 [Note] WSREP: Shifting JOINED -&gt; SYNCED (TO: 6)\n2023-08-03 19:27:10 2 [Note] WSREP: Server mariadb-galera-0 synced with group\n2023-08-03 19:27:10 2 [Note] WSREP: Server status change joined -&gt; synced\n2023-08-03 19:27:10 2 [Note] WSREP: Synchronized with group, ready for connections\n</code></pre> <p>Once you are done with these steps, you will have the context required to jump ahead to the Common errors section to see if any of them matches your case.  If they don't, feel free to open an issue or even a PR updating this document if you managed to resolve it.</p>"},{"location":"GALERA/#common-errors","title":"Common errors","text":""},{"location":"GALERA/#galera-cluster-recovery-not-progressing","title":"Galera cluster recovery not progressing","text":"<p>If your <code>MariaDB</code> Galera cluster has been in <code>GaleraNotReady</code> state for a long time, the recovery process might not be progressing. You can diagnose this by checking: - Operator logs. - Galera recovery status:</p> <pre><code>kubectl get mariadb mariadb-galera -o jsonpath=\"{.status.galeraRecovery}\" | jq\n</code></pre> <ul> <li><code>MariaDB</code> events:</li> </ul> <pre><code>kubectl get events --field-selector involvedObject.name=mariadb-galera\n</code></pre> <ul> <li>If you have <code>Pods</code> named <code>&lt;mariadb-name&gt;-&lt;ordinal&gt;-recovery-&lt;suffix&gt;</code> running for a long time, check its logs to understand if something is wrong.</li> </ul> <p>One of the reasons could be misconfigured Galera recovery <code>Jobs</code>, please make sure you read this section. If after checking all the points above, there are still no clear symptoms of what could be wrong, continue reading.</p> <p>First af all, you could attempt to forcefully bootstrap a new cluster as it is described in this section. Please, refrain from doing so if the conditions described in the docs are not met.</p> <p>Alternatively, if you can afford some downtime and your PVCs are in healthy state, you may follow this procedure: - Delete your existing <code>MariaDB</code>, this will leave your PVCs intact. - Create your <code>MariaDB</code> again, this will trigger a Galera recovery process as described in this section.</p> <p>As a last resource, you can always delete the PVCs and bootstrap a new <code>MariaDB</code> from a backup as documented here.</p>"},{"location":"GALERA/#permission-denied-writing-galera-configuration","title":"Permission denied writing Galera configuration","text":"<p>This error occurs when the user that runs the container does not have enough privileges to write in <code>/etc/mysql/mariadb.conf.d</code>:</p> <pre><code> Error writing Galera config: open /etc/mysql/mariadb.conf.d/0-galera.cnf: permission denied\n</code></pre> <p>To mitigate this, by default, the operator sets the following <code>securityContext</code> in the <code>MariaDB</code>'s <code>StatefulSet</code> :</p> <pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: mariadb-galera\nspec:\n  securityContext:\n    fsGroup: 999\n    runAsGroup: 999\n    runAsNonRoot: true\n    runAsUser: 999\n</code></pre> <p>This enables the <code>CSIDriver</code> and the kubelet to recursively set the ownership ofr the <code>/etc/mysql/mariadb.conf.d</code> folder to the group <code>999</code>, which is the one expected by MariaDB. It is important to note that not all the <code>CSIDrivers</code> implementations support this feature, see the CSIDriver documentation for further information.</p>"},{"location":"GALERA/#unauthorized-error-disabling-bootstrap","title":"Unauthorized error disabling bootstrap","text":"<pre><code>Error reconciling Galera: error disabling bootstrap in Pod 0: unauthorized\n</code></pre> <p>This situation occurs when the <code>mariadb-operator</code> credentials passed to the <code>agent</code> as authentication are either invalid or the <code>agent</code> is unable to verify them. To confirm this, ensure that both the <code>mariadb-operator</code> and the <code>MariaDB</code> <code>ServiceAccounts</code> are able to create <code>TokenReview</code> objects:</p> <pre><code>kubectl auth can-i --list --as=system:serviceaccount:default:mariadb-operator | grep tokenreview\ntokenreviews.authentication.k8s.io              []                                    []               [create]\n\nkubectl auth can-i --list --as=system:serviceaccount:default:mariadb-galera | grep tokenreview\ntokenreviews.authentication.k8s.io              []                                    []               [create]\n</code></pre> <p>If that's not the case, check that the following <code>ClusterRole</code> and <code>ClusterRoleBindings</code> are available in your cluster:</p> <pre><code>kubectl get clusterrole system:auth-delegator\nNAME                    CREATED AT\nsystem:auth-delegator   2023-08-03T19:12:37Z\n\nkubectl get clusterrolebinding | grep mariadb | grep auth-delegator\nmariadb-galera:auth-delegator                     ClusterRole/system:auth-delegator                                                  108m\nmariadb-operator:auth-delegator                        ClusterRole/system:auth-delegator                                                  112m\n</code></pre> <p><code>mariadb-operator:auth-delegator</code> is the <code>ClusterRoleBinding</code> bound to the <code>mariadb-operator</code> <code>ServiceAccount</code> which is created by the helm chart, so you can re-install the helm release in order to recreate it:</p> <pre><code> helm upgrade --install mariadb-operator mariadb-operator/mariadb-operator\n</code></pre> <p><code>mariadb-galera:auth-delegator</code> is the <code>ClusterRoleBinding</code> bound to the <code>mariadb-galera</code> <code>ServiceAccount</code> which is created on the flight by the operator as part of the reconciliation logic. You may check the <code>mariadb-operator</code> logs to see if there are any issues reconciling it.</p> <p>Bear in mind that <code>ClusterRoleBindings</code> are cluster-wide resources that are not garbage collected when the <code>MariaDB</code> owner object is deleted, which means that creating and deleting <code>MariaDBs</code> could leave leftovers in your cluster. These leftovers can lead to RBAC misconfigurations, as the <code>ClusterRoleBinding</code> might not be pointing to the right <code>ServiceAccount</code>. To overcome this, you can override the <code>ClusterRoleBinding</code> name setting the <code>spec.galera.agent.kubernetesAuth.authDelegatorRoleName</code> field.</p>"},{"location":"GALERA/#timeout-waiting-for-pod-to-be-synced","title":"Timeout waiting for Pod to be Synced","text":"<pre><code>Timeout waiting for Pod 'mariadb-galera-2' to be Synced\n</code></pre> <p>This error appears in the <code>mariadb-operator</code> logs when a <code>Pod</code> is in non synced state for a duration exceeding the <code>spec.galera.recovery.podRecoveryTimeout</code>. Just after, the operator will restart the <code>Pod</code>.</p> <p>Increase this timeout if you consider that your <code>Pod</code> may take longer to recover.</p>"},{"location":"GALERA/#galera-cluster-bootstrap-timed-out","title":"Galera cluster bootstrap timed out","text":"<pre><code>Galera cluster bootstrap timed out. Resetting recovery status\n</code></pre> <p>This is error is returned by the <code>mariadb-operator</code> after exceeding the <code>spec.galera.recovery.clusterBootstrapTimeout</code> when recovering the cluster. At this point, the operator will reset the recovered sequence numbers and start again from a clean state.</p> <p>Increase this timeout if you consider that your Galera cluster may take longer to recover.</p>"},{"location":"GALERA/#github-issues","title":"GitHub Issues","text":"<p>Here it is a list of Galera-related issues reported by <code>mariadb-operator</code> users which might shed some light in your investigation: - https://github.com/mariadb-operator/mariadb-operator/issues?q=label%3Agalera+</p>"},{"location":"GALERA/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> </ul>"},{"location":"HA/","title":"High availability","text":"<p>This section provide guidance on how to run <code>MariaDB</code> and <code>MaxScale</code> in high availability mode. If you are looking to run the operator in HA as well, please refer to the Helm documentation.</p> <p>Our recommended HA setup for production is: - Galera with at least 3 nodes. Always an odd number of nodes. - Load balance requests using MaxScale as database proxy. - Use dedicated nodes to avoid noisy neighbours. - Define pod disruption budgets.</p> <p>Refer to the following sections for further detail.</p>"},{"location":"HA/#table-of-contents","title":"Table of contents","text":"<ul> <li>Topologies</li> <li>Kubernetes Services</li> <li>MaxScale</li> <li>Pod Anti-Affinity</li> <li>Dedicated Nodes</li> <li>Pod Disruption Budgets</li> <li>Reference</li> </ul>"},{"location":"HA/#topologies","title":"Topologies","text":"<p>[!WARNING] SemiSync Replication is in alpha stage and not ready for production. Use it at your own risk.</p> <ul> <li>Multi master HA via Galera: All nodes support reads and writes. We have a designated primary where the writes are performed.</li> <li>Single master HA via SemiSync Replication: The primary node allows both reads and writes, while secondary nodes only allow reads.</li> </ul>"},{"location":"HA/#kubernetes-services","title":"Kubernetes Services","text":"<p>In order to address nodes, <code>mariadb-operator</code> provides you with the following Kubernetes <code>Services</code>: - <code>&lt;mariadb-name&gt;</code>: To be used for read requests. It will point to all nodes.  - <code>&lt;mariadb-name&gt;-primary</code>: To be used for write requests. It will point to a single node, the primary. - <code>&lt;mariadb-name&gt;-secondary</code>: To be used for read requests. It will point to all nodes, except the primary.</p> <p>Whenever the primary changes, either by the user or by the operator, both the <code>&lt;mariadb-name&gt;-primary</code> and <code>&lt;mariadb-name&gt;-secondary</code> <code>Services</code> will be automatically updated by the operator to address the right nodes.</p> <p>The primary may be manually changed by the user at any point by updating the <code>spec.[replication|galera].primary.podIndex</code> field. Alternatively,  automatic primary failover can be enabled by setting <code>spec.[replication|galera].primary.automaticFailover</code>, which will make the operator to switch primary whenever the primary <code>Pod</code> goes down.</p>"},{"location":"HA/#maxscale","title":"MaxScale","text":"<p>While Kubernetes <code>Services</code> can be utilized to dynamically address primary and secondary instances, the most robust high availability configuration we recommend relies on MaxScale. Please refer to MaxScale docs for further details.</p>"},{"location":"HA/#pod-anti-affinity","title":"Pod Anti-Affinity","text":"<p>[!WARNING] Bear in mind that, when enabling this, you need to have at least as many <code>Nodes</code> available as the replicas specified. Otherwise your <code>Pods</code> will be unscheduled and the cluster won't bootstrap.</p> <p>To achieve real high availability, we need to run each <code>MariaDB</code> <code>Pod</code> in different Kubernetes <code>Nodes</code>. This practice, known as anti-affinity, helps reducing the blast radius of <code>Nodes</code> being unavailable.</p> <p>By default, anti-affinity is disabled, which means that multiple <code>Pods</code> may be scheduled in the same <code>Node</code>, something not desired in HA scenarios.</p> <p>You can selectively enable anti-affinity in all the different <code>Pods</code> managed by the <code>MariaDB</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  bootstrapFrom:\n    restoreJob:\n      affinity:\n        antiAffinityEnabled: true\n  ...\n  galera:\n    initJob:\n      affinity:\n        antiAffinityEnabled: true\n  ...\n  metrics:\n    exporter:\n      affinity:\n        antiAffinityEnabled: true\n  ...\n  affinity:\n    antiAffinityEnabled: true\n</code></pre> <p>Anti-affinity may also be enabled in the the resources that have a reference to <code>MariaDB</code>, resulting in their <code>Pods</code> being scheduled in <code>Nodes</code> where <code>MariaDB</code> is not running. For instance, the <code>Backup</code> and <code>Restore</code> processes can run in different <code>Nodes</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  mariaDbRef:\n    name: mariadb-galera\n  ...\n  affinity:\n    antiAffinityEnabled: true\n</code></pre> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Restore\nmetadata:\n  name: restore\nspec:\n  mariaDbRef:\n    name: mariadb-galera\n  ...\n  affinity:\n    antiAffinityEnabled: true\n</code></pre> <p>In the case of <code>MaxScale</code>, the <code>Pods</code> will also be placed in <code>Nodes</code> isolated in terms of compute, ensuring isolation not only among themselves but also from the <code>MariaDB</code> <code>Pods</code>. For example, if you run a <code>MariaDB</code> and <code>MaxScale</code> with 3 replicas each, you will need 6 <code>Nodes</code> in total:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n  mariaDbRef:\n    name: mariadb-galera\n  ...\n  metrics:\n    exporter:\n      affinity:\n        antiAffinityEnabled: true\n  ...\n  affinity:\n    antiAffinityEnabled: true\n</code></pre> <p>Default anti-affinity rules generated by the operator might not satisfy your needs, but you can always define your own rules. For example, if you want the <code>MaxScale</code> <code>Pods</code> to be in different <code>Nodes</code>, but you want them to share <code>Nodes</code> with <code>MariaDB</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n  mariaDbRef:\n    name: mariadb-galera\n  ...\n  affinity:\n    podAntiAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n      - labelSelector:\n          matchExpressions:\n          - key: app.kubernetes.io/instance\n            operator: In\n            values:\n            - maxscale-galera\n            # 'mariadb-galera' instance omitted (default anti-affinity rule)\n        topologyKey: kubernetes.io/hostname\n</code></pre>"},{"location":"HA/#dedicated-nodes","title":"Dedicated Nodes","text":"<p>If you want to avoid noisy neighbours running in the same Kubernetes <code>Nodes</code> as your <code>MariaDB</code>, you may consider using dedicated <code>Nodes</code>. For achieving this, you will need: - Taint your <code>Nodes</code> and add the counterpart toleration in your <code>Pods</code>.</p> <p>[!IMPORTANT] Tainting your <code>Nodes</code> is not covered by this operator, it is something you need to do by yourself beforehand. You may take a look at the Kubernetes documentation to understand how to achieve this. - Select the <code>Nodes</code> to schedule in via a <code>nodeSelector</code> in your <code>Pods</code>. [!NOTE] Although you can use the default <code>Node</code> labels, you may consider adding more significative labels to your <code>Nodes</code>, as you will have to refer to them in your <code>Pod</code> <code>nodeSelector</code>. Refer to the Kubernetes documentation. </p> <ul> <li>Add <code>podAntiAffinity</code> to your <code>Pods</code> as described in the Pod Anti-Affinity section.</li> </ul> <p>Once you have completed the previous steps, you can configure your <code>MariaDB</code> as follows:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  tolerations:\n    - key: \"k8s.mariadb.com/ha\"\n      operator: \"Exists\"\n      effect: \"NoSchedule\"\n  nodeSelector:\n    \"k8s.mariadb.com/node\": \"ha\" \n  affinity:\n    antiAffinityEnabled: true\n</code></pre>"},{"location":"HA/#pod-disruption-budgets","title":"Pod Disruption Budgets","text":"<p>[!IMPORTANT] Take a look at the Kubernetes documentation if you are unfamiliar to <code>PodDisruptionBudgets</code></p> <p>By defining a <code>PodDisruptionBudget</code>, you are telling Kubernetes how many <code>Pods</code> your database tolerates to be down. This quite important for planned maintenance operations such as <code>Node</code> upgrades.</p> <p><code>mariadb-operator</code> creates a default <code>PodDisruptionBudget</code> if you are running in HA, but you are able to define your own by setting:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n    podDisruptionBudget:\n      maxUnavailable: 33%\n</code></pre>"},{"location":"HA/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> </ul>"},{"location":"HELM/","title":"Helm","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.32</p> <p>Helm is the preferred way to install <code>mariadb-operator</code> in vanilla Kubernetes clusters (i.e. not OpenShift). This doc aims to provide guidance on how to manage the installation and upgrades of both the CRDs and the operator via Helm charts.</p>"},{"location":"HELM/#table-of-contents","title":"Table of contents","text":"<ul> <li>Charts</li> <li>Control-plane</li> <li>Installing CRDs</li> <li>Installing the operator</li> <li>Deployment modes</li> <li>Updates</li> <li>High availability</li> <li>Uninstalling</li> </ul>"},{"location":"HELM/#charts","title":"Charts","text":"<p>The installation of <code>mariadb-operator</code> is splitted into two different helm charts for better convenience: - <code>mariadb-operator-crds</code>: Bundles the <code>CustomResourceDefinitions</code> required by the operator. - <code>mariadb-operator</code>: Contains all the template manifests required to install the operator.</p>"},{"location":"HELM/#control-plane","title":"Control-plane","text":"<p>The <code>mariadb-operator</code> is an extension of the Kubernetes control-plane, consisting of the following components that are deployed by Helm:</p> <ul> <li><code>operator</code>: The <code>mariadb-operator</code> itself that performs the CRD reconciliation.</li> <li><code>webhook</code>: The Kubernetes control-plane delegates CRD validations to this HTTP server. Kubernetes requires TLS to communicate with the webhook server.</li> <li><code>cert-controller</code>: Provisions TLS certificates for the webhook. You can see it as a minimal cert-manager that is intended to work only with the webhook. It is optional and can be replaced by cert-manager.</li> </ul>"},{"location":"HELM/#installing-crds","title":"Installing CRDs","text":"<p>Helm has certain limitations when it comes to manage CRDs. To address this, we are providing the CRDs in a separate chart, as recommended by the official Helm documentation. This allows us to manage the installation and updates of the CRDs independently from the operator. For example, you can uninstall the operator without impacting your existing <code>MariaDB</code> CRDs.</p> <p>CRDs can be installed in your cluster by running the following commands</p> <pre><code>helm repo add mariadb-operator https://helm.mariadb.com/mariadb-operator\nhelm install mariadb-operator-crds mariadb-operator/mariadb-operator-crds\n</code></pre>"},{"location":"HELM/#installing-the-operator","title":"Installing the operator","text":"<p>Once the CRDs are available in the cluster, you can proceed to install the operator:</p> <pre><code>helm repo add mariadb-operator https://helm.mariadb.com/mariadb-operator\nhelm install mariadb-operator mariadb-operator/mariadb-operator\n</code></pre> <p>If you have the prometheus operator and cert-manager already installed in your cluster, it is recommended to leverage them to scrape the operator metrics and provision the webhook certificate respectively:</p> <pre><code>helm repo add mariadb-operator https://helm.mariadb.com/mariadb-operator\nhelm install mariadb-operator mariadb-operator/mariadb-operator \\\n  --set metrics.enabled=true --set webhook.cert.certManager.enabled=true\n</code></pre> <p>Refer to the helm chart README for detailed information about all the supported helm values.</p>"},{"location":"HELM/#deployment-modes","title":"Deployment modes","text":"<p>Deployments are highly configurable via the helm values. In particular the following deployment modes are supported:</p>"},{"location":"HELM/#cluster-wide","title":"Cluster-wide","text":"<p>The operator watches CRDs in all namespaces and requires cluster-wide RBAC permissions to operate. This is the default deployment mode, enabled through the default configuration values:</p> <pre><code>helm repo add mariadb-operator https://helm.mariadb.com/mariadb-operator\nhelm install mariadb-operator mariadb-operator/mariadb-operator\n</code></pre>"},{"location":"HELM/#single-namespace","title":"Single namespace","text":"<p>By setting <code>currentNamespaceOnly=true</code>, the operator will only watch CRDs within the namespace it is deployed in, and the RBAC permissions will be restricted to that namespace as well:</p> <pre><code>helm repo add mariadb-operator https://helm.mariadb.com/mariadb-operator\nhelm install mariadb-operator \\\n  -n databases --create-namespace \\\n  --set currentNamespaceOnly=true \\\n  mariadb-operator/mariadb-operator\n</code></pre>"},{"location":"HELM/#updates","title":"Updates","text":"<p>[!IMPORTANT] Make sure you read and understand the updates documentation before proceeding to update the operator.</p> <p>The first step to perform an operator update is upgrading the CRDs:</p> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator-crds \\\n  --version &lt;new-version&gt; \\\n  mariadb-operator/mariadb-operator-crds\n</code></pre> <p>Once updated, you may proceed to upgrade the operator:</p> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator \\\n  --version &lt;new-version&gt; \\\n  mariadb-operator/mariadb-operator \n</code></pre> <p>Whenever a new version of the <code>mariadb-operator</code> is released, an upgrade guide is linked in the release notes if additional upgrade steps are required. Be sure to review the release notes and follow the version-specific upgrade guides accordingly.</p>"},{"location":"HELM/#high-availability","title":"High availability","text":"<p>The operator can run in high availability mode to ensure that your CRs get reconciled even if the node where the operator runs goes down. For achieving this you need: - Multiple replicas - Configure <code>Pod</code> anti-affinity - Configure <code>PodDisruptionBudgets</code> </p> <p>You can achieve this by providing the following values to the helm chart:</p> <pre><code>ha:\n  enabled: true\n  replicas: 3\n\naffinity:\n  podAntiAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n        matchExpressions:\n        - key: app.kubernetes.io/name\n          operator: In\n          values:\n          - mariadb-operator\n        - key: app.kubernetes.io/instance\n          operator: In\n          values:\n          - mariadb-operator\n      topologyKey: kubernetes.io/hostname\n\npdb:\n  enabled: true\n  maxUnavailable: 1\n</code></pre>"},{"location":"HELM/#uninstalling","title":"Uninstalling","text":"<p>[!CAUTION] Uninstalling the <code>mariadb-operator-crds</code> Helm chart will remove the CRDs and their associated resources, resulting in downtime.</p> <p>First, uninstall the <code>mariadb-operator</code> Helm chart. This action will not delete your CRDs, so your operands (i.e. <code>MariaDB</code> and <code>MaxScale</code>) will continue to run without the operator's reconciliation.</p> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>At this point, if you also want to delete CRDs and the operands running in your cluster, you may proceed to uninstall the <code>mariadb-operator-crds</code> Helm chart:</p> <pre><code>helm uninstall mariadb-operator-crds\n</code></pre>"},{"location":"MAXSCALE/","title":"MaxScale","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.25</p> <p>[!IMPORTANT] MaxScale 23.08 is licensed under Business Source License. Make sure you understand the implications before using it!</p> <p>MaxScale is a sophisticated database proxy, router, and load balancer designed specifically for and by MariaDB. It provides a range of features that ensure optimal high availability: - Query-based routing: Transparently route write queries to the primary nodes and read queries to the replica nodes. - Connection-based routing: Load balance connections between multiple servers. - Automatic primary failover based on MariaDB internals. - Replay pending transactions when a server goes down. - Support for Galera and Replication.</p> <p>To better understand what MaxScale is capable of you may check the product page and the documentation. </p>"},{"location":"MAXSCALE/#table-of-contents","title":"Table of contents","text":"<ul> <li>MaxScale resources</li> <li><code>MaxScale</code> CR</li> <li><code>MariaDB</code> CR</li> <li><code>MaxScale</code> embedded in <code>MariaDB</code></li> <li>Defaults</li> <li>Server configuration</li> <li>Server maintenance</li> <li>Configuration</li> <li>Authentication</li> <li>Kubernetes <code>Services</code></li> <li>Connection</li> <li>High availability</li> <li>Suspend resources</li> <li>MaxScale GUI</li> <li>MaxScale API</li> <li>Troubleshooting</li> <li>Reference</li> </ul>"},{"location":"MAXSCALE/#maxscale-resources","title":"MaxScale resources","text":"<p>Prior to configuring MaxScale within Kubernetes, it's essential to have a basic understanding of the resources managed through its API.</p>"},{"location":"MAXSCALE/#servers","title":"Servers","text":"<p>A server defines the backend database servers that MaxScale forwards traffic to. For more detailed information, please consult the server reference.</p>"},{"location":"MAXSCALE/#monitors","title":"Monitors","text":"<p>A monitor is an agent that queries the state of the servers and makes it available to the services in order to route traffic based on it. For more detailed information, please consult the monitor reference.</p> <p>Depending on which highly available configuration your servers have, you will need to choose betweeen the following modules: - Galera Monitor: Detects whether servers are part of the cluster, ensuring synchronization among them, and assigning primary and replica roles as needed. - MariaDB Monitor: Probes the state of the cluster, assigns roles to the servers, and executes failover, switchover, and rejoin operations as necessary.</p>"},{"location":"MAXSCALE/#services","title":"Services","text":"<p>A service defines how the traffic is routed to the servers based on a routing algorithm that takes into account the state of the servers and its role. For more detailed information, please consult the service reference.</p> <p>Depending on your requirements to route traffic, you may choose between the following routers: - Readwritesplit: Route write queries to the primary server and read queries to the replica servers. - Readconnroute: Load balance connections between multiple servers.</p>"},{"location":"MAXSCALE/#listeners","title":"Listeners","text":"<p>A listener specifies a port where MaxScale listens for incoming connections. It is associated with a service that handles the requests received on that port. For more detailed information, please consult the listener reference.</p>"},{"location":"MAXSCALE/#maxscale-cr","title":"<code>MaxScale</code> CR","text":"<p>The minimal spec you need to provision a MaxScale instance is just a reference to a <code>MariaDB</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n  mariaDbRef:\n    name: mariadb-galera\n</code></pre> <p>This will provision a new <code>StatefulSet</code> for running MaxScale and configure the servers specified by the <code>MariaDB</code> resource. Refer to the Server configuration section if you want to manually configure the MariaDB servers.</p> <p>The rest of the configuration uses reasonable defaults set automatically by the operator. If you need a more fine grained configuration, you can provide this values yourself:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  mariaDbRef:\n    name: mariadb-galera\n\n  services:\n    - name: rw-router\n      router: readwritesplit\n      params:\n        transaction_replay: \"true\"\n        transaction_replay_attempts: \"10\"\n        transaction_replay_timeout: \"5s\"\n        max_slave_connections: \"255\"\n        max_replication_lag: \"3s\"\n        master_accept_reads: \"true\"\n      listener:\n        port: 3306\n        protocol: MariaDBProtocol\n        params:\n          connection_metadata: \"tx_isolation=auto\"\n    - name: rconn-master-router\n      router: readconnroute\n      params:\n        router_options: \"master\"\n        max_replication_lag: \"3s\"\n        master_accept_reads: \"true\"\n      listener:\n        port: 3307\n    - name: rconn-slave-router\n      router: readconnroute\n      params:\n        router_options: \"slave\"\n        max_replication_lag: \"3s\"\n      listener:\n        port: 3308\n\n  monitor:\n    interval: 2s\n    cooperativeMonitoring: majority_of_all\n    params:\n      disable_master_failback: \"false\"\n      available_when_donor: \"false\"\n      disable_master_role_setting: \"false\"\n\n  kubernetesService:\n    type: LoadBalancer\n    metadata:\n      annotations:\n        metallb.universe.tf/loadBalancerIPs: 172.18.0.224\n</code></pre> <p>As you can see, the MaxScale resources we previously mentioned have a counterpart resource in the <code>MaxScale</code> CR. </p> <p>The previous example configured a <code>MaxScale</code> for a Galera cluster, but you may also configure <code>MaxScale</code> with a <code>MariaDB</code> that uses replication. It is important to note that the monitor module is automatically inferred by the operator based on the <code>MariaDB</code> reference you provided, however, its parameters are specific to each monitor module:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-repl\nspec:\n...\n  mariaDbRef:\n    name: mariadb-repl\n\n  services:\n    - name: rw-router\n      router: readwritesplit\n      params:\n        transaction_replay: \"true\"\n        transaction_replay_attempts: \"10\"\n        transaction_replay_timeout: \"5s\"\n        max_slave_connections: \"255\"\n        max_replication_lag: \"3s\"\n        master_accept_reads: \"true\"\n      listener:\n        port: 3306\n        protocol: MariaDBProtocol\n        params:\n          connection_metadata: \"tx_isolation=auto\"\n    - name: rconn-master-router\n      router: readconnroute\n      params:\n        router_options: \"master\"\n        max_replication_lag: \"3s\"\n        master_accept_reads: \"true\"\n      listener:\n        port: 3307\n    - name: rconn-slave-router\n      router: readconnroute\n      params:\n        router_options: \"slave\"\n        max_replication_lag: \"3s\"\n      listener:\n        port: 3308\n\n  monitor:\n    interval: 2s\n    cooperativeMonitoring: majority_of_all\n    params:\n      auto_failover: \"true\"\n      auto_rejoin: \"true\"\n      switchover_on_low_disk_space: \"true\"\n\n  kubernetesService:\n    type: LoadBalancer\n    metadata:\n      annotations:\n        metallb.universe.tf/loadBalancerIPs: 172.18.0.214\n</code></pre> <p>You also need to set a reference in the <code>MariaDB</code> resource to make it <code>MaxScale</code>-aware. This is explained in the MariaDB CR section.</p> <p>Refer to the Reference section for further detail.</p>"},{"location":"MAXSCALE/#mariadb-cr","title":"<code>MariaDB</code> CR","text":"<p>You can set a <code>spec.maxScaleRef</code> in your <code>MariaDB</code> resource to make it <code>MaxScale</code>-aware. By doing so, the primary server reported by <code>MaxScale</code> will be used in <code>MariaDB</code> and the high availability tasks such the primary failover will be delegated to <code>MaxScale</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n...\n  maxScaleRef:\n    name: maxscale-galera\n\n  galera:\n    enabled: true\n</code></pre> <p>Refer to the Reference section for further detail.</p>"},{"location":"MAXSCALE/#maxscale-embedded-in-mariadb","title":"<code>MaxScale</code> embedded in <code>MariaDB</code>","text":"<p>To streamline the setup outlined in the MaxScale CR and MariaDB CR sections, you can provision a <code>MaxScale</code> to be used with <code>MariaDB</code> in just one resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n...\n  maxScale:\n    enabled: true\n\n    kubernetesService:\n      type: LoadBalancer\n      metadata:\n        annotations:\n          metallb.universe.tf/loadBalancerIPs: 172.18.0.229\n\n  galera:\n    enabled: true\n</code></pre> <p>This will automatically set the references between <code>MariaDB</code> and <code>MaxScale</code> and default the rest of the fields.</p> <p>It is important to note that, this is intended for simple use cases where no further modifications are done on the <code>spec.maxscale</code> field. If you need a more fine grained configuration and perform further updates to the <code>MaxScale</code> resource, please use a dedicated <code>MaxScale</code> as described in the MaxScale CR section.</p> <p>Refer to the Reference section for further detail.</p>"},{"location":"MAXSCALE/#defaults","title":"Defaults","text":"<p><code>mariadb-operator</code> aims to provide highly configurable CRs, but at the same maximize its usability by providing reasonable defaults. In the case of <code>MaxScale</code>, the following defaulting logic is applied: - <code>spec.servers</code> are inferred from <code>spec.mariaDbRef</code>. - <code>spec.monitor.module</code> is inferred from the <code>spec.mariaDbRef</code>. - <code>spec.monitor.cooperativeMonitoring</code> is set if high availability is enabled. - If <code>spec.services</code> is not provided, the following are configured by default:   - <code>readwritesplit</code> service on port <code>3306</code>.   - <code>readconnroute</code> service pointing to the primary node on port <code>3307</code>.   - <code>readconnroute</code> service pointing to the replica nodes on port <code>3308</code>.</p>"},{"location":"MAXSCALE/#server-configuration","title":"Server configuration","text":"<p>As an alternative to provide a reference to a <code>MariaDB</code> via <code>spec.mariaDbRef</code>, you can also specify the servers manually:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  servers:\n    - name: mariadb-0\n      address: mariadb-galera-0.mariadb-galera-internal.default.svc.cluster.local\n    - name: mariadb-1\n      address: mariadb-galera-1.mariadb-galera-internal.default.svc.cluster.local\n    - name: mariadb-2\n      address: mariadb-galera-2.mariadb-galera-internal.default.svc.cluster.local\n</code></pre> <p>As you could see, you can refer to in-cluser MariaDB servers by providing the DNS names of the <code>MariaDB</code> <code>Pods</code> as server addresses. In addition, you can also refer to external MariaDB instances running outside of the Kubernetes cluster where <code>mariadb-operator</code> was deployed:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  servers:\n    - name: mariadb-0\n      address: 172.18.0.140\n      port: 3306\n    - name: mariadb-1\n      address: 172.18.0.141\n    - name: mariadb-2\n      address: 172.18.0.142\n\n  monitor:\n    name: mariadb-monitor\n    module: galeramon\n    interval: 2s\n    cooperativeMonitoring: majority_of_all\n    params:\n      disable_master_failback: \"false\"\n      available_when_donor: \"false\"\n      disable_master_role_setting: \"false\"\n\n  auth:\n    adminUsername: mariadb-operator\n    adminPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    clientUsername: maxscale-client\n    clientPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    serverUsername: maxscale-server\n    serverPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    monitorUsername: maxscale-monitor\n    monitorPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    syncUsername: maxscale-sync\n    syncPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n</code></pre> <p>\u26a0\ufe0f Pointing to external MariaDBs has a some limitations \u26a0\ufe0f. Since the operator doesn't have a reference to a <code>MariaDB</code> resource (<code>spec.mariaDbRef</code>), it will be unable to perform the following actions: - Infer the monitor module (<code>spec.monitor.module</code>), so it will need to be provided by the user. - Autogenerate authentication credentials (<code>spec.auth</code>), so they will need to be provided by the user. See Authentication section. </p>"},{"location":"MAXSCALE/#server-maintenance","title":"Server maintenance","text":"<p>You can put servers in maintenance mode by setting <code>maintenance = true</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  servers:\n    - name: mariadb-0\n      address: mariadb-galera-0.mariadb-galera-internal.default.svc.cluster.local\n      port: 3306\n      protocol: MariaDBBackend\n      maintenance: true\n</code></pre> <p>Maintenance mode prevents MaxScale from routing traffic to the server and also excludes it from being elected as the new primary during failover events.</p>"},{"location":"MAXSCALE/#configuration","title":"Configuration","text":"<p>Similar to MariaDB, MaxScale allows you to provide global configuration parameters in a <code>maxscale.conf</code> file. You don't need to provide this config file directly, but instead you can use the <code>spec.config.params</code> to instruct the operator to create the <code>maxscale.conf</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  config:\n    params:\n      log_info: \"true\"\n    volumeClaimTemplate:\n      resources:\n        requests:\n          storage: 100Mi\n      accessModes:\n        - ReadWriteOnce\n</code></pre> <p>Both this global configuration and the resources created by the operator using the MaxScale API are stored under a volume provisioned by the <code>spec.config.volumeClaimTemplate</code>. Refer to the troubleshooting if you are getting errors writing on this volume.</p> <p>Refer to the MaxScale reference to provide global configuration.</p>"},{"location":"MAXSCALE/#authentication","title":"Authentication","text":"<p>MaxScale requires authentication with differents levels of permissions for the following components/actors: - MaxScale API consumed by <code>mariadb-operator</code>. - Clients connecting to MaxScale. - MaxScale connecting to MariaDB servers. - MaxScale monitor connecting to MariaDB servers. - MaxScale configuration sync to connect to MariaDB servers. See high availability section.</p> <p>By default, <code>mariadb-operator</code> autogenerates this credentials when <code>spec.mariaDbRef</code> is set and <code>spec.auth.generate = true</code>, but you are still able to provide your own:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  auth:\n    generate: false\n    adminUsername: mariadb-operator\n    adminPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    deleteDefaultAdmin: true\n    clientUsername: maxscale-client\n    clientPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    clientMaxConnections: 90\n    serverUsername: maxscale-server\n    serverPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    serverMaxConnections: 90 \n    monitorUsername: maxscale-monitor\n    monitorPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    monitorMaxConnections: 90 \n    syncUsername: maxscale-sync\n    syncPasswordSecretKeyRef:\n      name: maxscale\n      key: password\n    syncMaxConnections: 90\n</code></pre> <p>As you could see, you are also able to limit the number of connections for each component/actor. Bear in mind that, when running in high availability, you may need to increase this number, as more MaxScale instances implies more connections.</p>"},{"location":"MAXSCALE/#kubernetes-services","title":"Kubernetes <code>Services</code>","text":"<p>To enable your applications to communicate with MaxScale, a Kubernetes <code>Service</code> is provisioned with all the ports specified in the MaxScale listeners. You have the flexibility to provide a template to customize this <code>Service</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  kubernetesService:\n    type: LoadBalancer\n    metadata:\n      annotations:\n        metallb.universe.tf/loadBalancerIPs: 172.18.0.224\n</code></pre> <p>This results in the reconciliation of the following <code>Service</code>:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  annotations:\n    metallb.universe.tf/loadBalancerIPs: 172.18.0.229\n  name: maxscale-galera\nspec:\n...\n  ports:\n  - name: admin\n    port: 8989\n    targetPort: 8989\n  - name: rw-router-listener\n    port: 3306\n    targetPort: 3306\n  - name: rconn-master-router-listener\n    port: 3307\n    targetPort: 3307\n  - name: rconn-slave-router-listener\n    port: 3308\n    targetPort: 3308\n  selector:\n    app.kubernetes.io/instance: maxscale-galera\n    app.kubernetes.io/name: maxscale\n  type: LoadBalancer\n</code></pre> <p>There is also another Kubernetes <code>Service</code> to access the GUI, please refer to the MaxScale GUI section for further detail.</p>"},{"location":"MAXSCALE/#connection","title":"Connection","text":"<p>You can leverage the <code>Connection</code> resource to automatically configure connection strings as <code>Secret</code> resources that your applications can mount:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Connection\nmetadata:\n  name: connection-maxscale\nspec:\n  maxScaleRef:\n    name: maxscale-galera\n  username: maxscale-galera-client\n  passwordSecretKeyRef:\n    name: maxscale-galera-client\n    key: password\n  secretName: conn-mxs\n  port: 3306\n</code></pre> <p>Alternatively, you can also provide a connection template to your <code>MaxScale</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...  \n  connection:\n    secretName: mxs-galera-conn\n    port: 3306\n</code></pre> <p>Note that, the <code>Connection</code> uses the <code>Service</code> described in the Kubernetes Service section and you are able to specify which MaxScale service to connect to by providing the port (<code>spec.port</code>) of the corresponding MaxScale listener.</p>"},{"location":"MAXSCALE/#high-availability","title":"High availability","text":"<p>To synchronize the configuration state across multiple replicas, MaxScale stores the configuration externally in a MariaDB table and conducts periodic polling across all replicas. By default, the table <code>mysql.maxscale_config</code> is used, but this can be configured by the user as well as the synchronization interval.</p> <p>Another crucial aspect to consider regarding HA is that only one monitor can be running at any given time to avoid conflicts. This can be achieved via cooperative locking, which can be configured by the user. Refer to MaxScale docs for more information.</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  replicas: 3\n\n  monitor:\n    name: mariadb-monitor\n    module: galeramon\n    interval: 2s\n    cooperativeMonitoring: majority_of_all\n    params:\n      disable_master_failback: \"false\"\n      available_when_donor: \"false\"\n      disable_master_role_setting: \"false\"   \n\n  config:\n    sync:\n      database: mysql\n      interval: 5s\n      timeout: 10s\n</code></pre> <p>Multiple <code>MaxScale</code> replicas can be specified by providing the <code>spec.replicas</code> field. Note that, <code>MaxScale</code> exposes the scale subresource, so you can scale/downscale it by running the following command:</p> <pre><code>kubectl scale maxscale maxscale-galera --replicas 3\n</code></pre> <p>Or even configuring an <code>HorizontalPodAutoscaler</code> to do the job automatically.</p>"},{"location":"MAXSCALE/#suspend-resources","title":"Suspend resources","text":"<p>In order to enable this feature, you must set the <code>--feature-maxscale-suspend</code> feature flag:</p> <pre><code>helm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --set extraArgs={--feature-maxscale-suspend}\n</code></pre> <p>Then you will be able to suspend any MaxScale resources, for instance, you can suspend a monitor:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  monitor:\n    name: mariadb-monitor\n    module: galeramon\n    interval: 2s\n    cooperativeMonitoring: majority_of_all\n    params:\n      disable_master_failback: \"false\"\n      available_when_donor: \"false\"\n      disable_master_role_setting: \"false\"   \n    suspend: true\n</code></pre>"},{"location":"MAXSCALE/#maxscale-gui","title":"MaxScale GUI","text":"<p>MaxScale offers a shiny user interface that provides very useful information about the MaxScale resources. You can  enable it providing the following configuration:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale-galera\nspec:\n...\n  admin:\n    port: 8989\n    guiEnabled: true\n  guiKubernetesService:\n    type: LoadBalancer\n    metadata:\n      metadata:\n        annotations:\n          metallb.universe.tf/loadBalancerIPs: 172.18.0.231\n</code></pre> <p>The GUI is exposed via a dedicated Kubernetes <code>Service</code> in the same port as the MaxScale API. Once you access, you will need to enter the MaxScale API credentials configured by <code>mariadb-operator</code> in a <code>Secret</code>. See the Authentication section for more details.</p> <p></p>"},{"location":"MAXSCALE/#maxscale-api","title":"MaxScale API","text":"<p><code>mariadb-operator</code> interacts with the MaxScale REST API to reconcile the specification provided by the user, considering both the MaxScale status retrieved from the API and the provided spec.</p> <p></p>"},{"location":"MAXSCALE/#troubleshooting","title":"Troubleshooting","text":"<p><code>mariadb-operator</code> tracks both the <code>MaxScale</code> status in regards to Kubernetes resources as well as the status of the MaxScale API resources. This information is available on the status field of the <code>MaxScale</code> resource, it may be very useful for debugging purposes:</p> <pre><code>status:\n  conditions:\n  - lastTransitionTime: \"2024-02-08T17:29:01Z\"\n    message: Running\n    reason: MaxScaleReady\n    status: \"True\"\n    type: Ready\n  configSync:\n    databaseVersion: 20\n    maxScaleVersion: 20\n  listeners:\n  - name: rconn-master-router-listener\n    state: Running\n  - name: rconn-slave-router-listener\n    state: Running\n  - name: rw-router-listener\n    state: Running\n  monitor:\n    name: galeramon-monitor\n    state: Running\n  primaryServer: mariadb-galera-1\n  replicas: 1\n  servers:\n  - name: mariadb-galera-0\n    state: Slave, Synced, Running\n  - name: mariadb-galera-1\n    state: Master, Synced, Running\n  - name: mariadb-galera-2\n    state: Slave, Synced, Running\n  services:\n  - name: rconn-master-router\n    state: Started\n  - name: rconn-slave-router\n    state: Started\n  - name: rw-router\n    state: Started\n</code></pre> <p>Kubernetes events emitted by <code>mariadb-operator</code> may also be very relevant for debugging. For instance, an event is emitted whenever the primary server changes:</p> <pre><code>kubectl get events --field-selector involvedObject.name=mariadb-repl-maxscale --sort-by='.lastTimestamp'\n\nLAST SEEN   TYPE      REASON                         OBJECT                           MESSAGE\n24s         Normal    MaxScalePrimaryServerChanged   maxscale/mariadb-repl-maxscale   MaxScale primary server changed from 'mariadb-repl-0' to 'mariadb-repl-1'\n</code></pre> <p><code>mariadb-operator</code> logs can also be a good source of information for troubleshooting. You can increase its verbosity and enable MaxScale API request logs by running:</p> <pre><code>helm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --set logLevel=debug --set extraArgs={--log-maxscale}\n</code></pre>"},{"location":"MAXSCALE/#common-errors","title":"Common errors","text":""},{"location":"MAXSCALE/#permission-denied-writing-varlibmaxscale","title":"Permission denied writing <code>/var/lib/maxscale</code>","text":"<p>This error occurs when the user that runs the container does not have enough privileges to write in <code>/var/lib/maxscale</code>:</p> <pre><code>Failed to create directory '/var/lib/maxscale/maxscale.cnf.d': 13, Permission denied\n</code></pre> <p>To mitigate this, by default, the operator sets the following <code>securityContext</code> in the <code>MaxScale</code>'s <code>StatefulSet</code>:</p> <pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: maxscale-galera\nspec:\n  securityContext:\n    fsGroup: 996\n    runAsGroup: 996\n    runAsNonRoot: true\n    runAsUser: 998\n</code></pre> <p>This enables the <code>CSIDriver</code> and the kubelet to recursively set the ownership ofr the <code>/var/lib/maxscale</code> folder to the group <code>996</code>, which is the one expected by MaxScale. It is important to note that not all the <code>CSIDrivers</code> implementations support this feature, see the CSIDriver documentation for further information.</p>"},{"location":"MAXSCALE/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> </ul>"},{"location":"METADATA/","title":"Metadata","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.28</p> <p>This documentation shows how to configure metadata in the <code>mariadb-operator</code> CRs.</p>"},{"location":"METADATA/#table-of-contents","title":"Table of contents","text":"<ul> <li>Children object metadata</li> <li><code>Pod</code> metadata</li> <li><code>Service</code> metadata</li> <li><code>PVC</code> metadata</li> <li>Use cases</li> <li>Reference</li> </ul>"},{"location":"METADATA/#children-object-metadata","title":"Children object metadata","text":"<p><code>MariaDB</code> and <code>MaxScale</code> resources allow you to propagate metadata to all the children objects by specifying the <code>inheritMetadata</code> field:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  inheritMetadata:\n    labels:\n      database.myorg.io: mariadb\n    annotations:\n      database.myorg.io: mariadb\n</code></pre> <p>This means that all the reconciled objects will inherit these labels and annotations. For instance, see the <code>Services</code> and <code>Pods</code>:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  annotations:\n    database.myorg.io: mariadb\n  labels:\n    database.myorg.io: mariadb\n  name: mariadb-galera-primary\n  namespace: default\n</code></pre> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    database.myorg.io: mariadb\n  labels:\n    database.myorg.io: mariadb\n  name: mariadb-galera-0\n  namespace: default\n</code></pre>"},{"location":"METADATA/#pod-metadata","title":"<code>Pod</code> metadata","text":"<p>You have the ability to provide dedicated metadata for <code>Pods</code> by specifying the <code>podMetadata</code> field in any CR that reconciles a <code>Pod</code>, for instance: <code>MariaDB</code>, <code>MaxScale</code>, <code>Backup</code>, <code>Restore</code> and <code>SqlJobs</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  inheritMetadata:\n    labels:\n      sidecar.istio.io/inject: \"true\"\n    annotations:\n      database.myorg.io: mariadb\n  podMetadata:\n    labels:\n      sidecar.istio.io/inject: \"false\"\n</code></pre> <p>It is important to note that the <code>podMetadata</code> field superseeds the <code>inheritMetadata</code> field, therefore the labels and annotations provided in the former will override the ones in the latter.</p>"},{"location":"METADATA/#service-metadata","title":"<code>Service</code> metadata","text":"<p>Provision dedicated metadata for <code>Services</code> in the <code>MariaDB</code> resources can be done via the <code>service</code>, <code>primaryService</code> and <code>secondaryService</code> fields:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  service:\n    type: LoadBalancer\n    metadata:\n      annotations:\n        metallb.universe.tf/loadBalancerIPs: 172.18.0.150\n\n  primaryService:\n    type: LoadBalancer\n    metadata:\n      annotations:\n        metallb.universe.tf/loadBalancerIPs: 172.18.0.160\n\n  secondaryService:\n    type: LoadBalancer\n    metadata:\n      annotations:\n        metallb.universe.tf/loadBalancerIPs: 172.18.0.161\n</code></pre> <p>In the case of <code>MaxScale</code>, you can also do this via the <code>kubernetesService</code> field.</p> <p>Refer to the HA documentation to know more about the <code>Service</code> fields and <code>MaxScale</code>.</p>"},{"location":"METADATA/#pvc-metadata","title":"<code>PVC</code> metadata","text":"<p>Both <code>MariaDB</code> and <code>MaxScale</code> allow you to define a <code>volumeClaimTemplate</code> to be used by the underlying <code>StatefulSet</code>. You may also define metadata for it:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  storage:\n    size: 1Gi\n    volumeClaimTemplate:\n      metadata:\n        annotations:\n          database.myorg.io: mariadb\n        labels:\n          database.myorg.io: mariadb\n      accessModes:\n      - ReadWriteOnce\n      resources:\n        requests:\n          storage: 1Gi\n</code></pre>"},{"location":"METADATA/#use-cases","title":"Use cases","text":"<p>Being able to provide metadata allows you to integrate with other CNCF landscape projects:</p>"},{"location":"METADATA/#metallb","title":"Metallb","text":"<p>If you run on bare metal and you use Metallb for managing the <code>LoadBalancer</code> objects, you can declare its IPs via annotations:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  service:\n    type: LoadBalancer\n    metadata:\n      annotations:\n        metallb.universe.tf/loadBalancerIPs: 172.18.0.150\n</code></pre>"},{"location":"METADATA/#istio","title":"Istio","text":"<p>Istio injects the data-plane container to all <code>Pods</code>, but you might want to opt-out of this feature in some cases:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  podMetadata:\n    labels:\n      sidecar.istio.io/inject: \"false\"\n</code></pre> <p>For instance, you probably don't want to inject the Istio sidecar to <code>Backup</code> <code>Pods</code>, as it will prevent the <code>Jobs</code> from finishing and therefore your backup process will hang.</p>"},{"location":"METADATA/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> </ul>"},{"location":"METRICS/","title":"Prometheus metrics","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.24</p> <p><code>mariadb-operator</code> is able to provision MariaDB instances and automatically configure Prometheus to scrape their metrics so they can be used later on to build Grafana dashboards or trigger Alertmanager alerts.</p>"},{"location":"METRICS/#table-of-contents","title":"Table of contents","text":"<ul> <li>Operator metrics</li> <li>Exporter</li> <li><code>ServiceMonitor</code></li> <li>Configuration</li> <li>Prometheus reference installation</li> <li>Grafana dashboards</li> <li>Reference</li> </ul>"},{"location":"METRICS/#operator-metrics","title":"Operator metrics","text":"<p>In order to expose the operator internal metrics, please refer to the recommended installation flavour.</p>"},{"location":"METRICS/#exporter","title":"Exporter","text":"<p>The operator configures a prometheus/mysqld-exporter exporter to query MariaDB and export the metrics in Prometheus format via an http endpoint.</p> <p>It is important to note that, we run this exporter as an standalone <code>Deployment</code> and not as a sidecar alongside every MariaDB replica. This implies that the MariaDB lifecycle is not coupled to the exporter one, so we can upgrade them independently without affecting the availability of the other.</p> <p>For being able to do this, we rely on the multi-target feature introduced in the v0.15.0 of prometheus/mysqld-exporter, so make sure to specify at least v0.15.0 in the exporter image.</p>"},{"location":"METRICS/#servicemonitor","title":"<code>ServiceMonitor</code>","text":"<p>Once the exporter <code>Deployment</code> is ready, <code>mariadb-operator</code> creates a ServiceMonitor object that will be eventually reconciled by the Prometheus operator , resulting in the Prometheus instance being configured to scrape the exporter endpoint.</p> <p>As you scale your MariaDB with more or less replicas, <code>mariadb-operator</code> will reconcile the <code>ServiceMonitor</code> to add/remove targets related to the MariaDB instances. </p>"},{"location":"METRICS/#configuration","title":"Configuration","text":"<p>The easiest way to setup metrics in your MariaDB instance is just by setting <code>spec.metrics.enabled = true</code>, like in this example:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n...\n  metrics:\n    enabled: true\n</code></pre> <p>The rest of the fields are defaulted by the operator. If you need a more fine grained configuration, refer to the API reference and take a look at this example:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n...\n  metrics:\n    enabled: true\n    exporter:\n      image: prom/mysqld-exporter:v0.15.1\n      resources:\n        requests:\n          cpu: 50m\n          memory: 64Mi\n        limits:\n          cpu: 300m\n          memory: 512Mi\n      port: 9104\n    serviceMonitor:\n      prometheusRelease: kube-prometheus-stack\n      jobLabel: mariadb-monitoring\n      interval: 10s\n      scrapeTimeout: 10s\n    username: monitoring\n    passwordSecretKeyRef:\n      name: mariadb\n      key: password\n</code></pre>"},{"location":"METRICS/#prometheus-reference-installation","title":"Prometheus reference installation","text":"<p>The easiest way to spin up a Prometheus observability stack in Kubernetes is by installing the kube-prometheus-stack helm chart.</p> <p>We leverage this chart in our local development environment and we have configured it to ensure quality interactions between <code>mariadb-operator</code> and Prometheus. Feel free to install it by running:</p> <pre><code>make cluster\nmake install-prometheus\n</code></pre>"},{"location":"METRICS/#grafana-dashboards","title":"Grafana dashboards","text":"<p>To visualize MariaDB metrics, our Prometheus reference installation has some interesting Grafana dashboards configured that make use of the metrics configured by <code>mariadb-operator</code>. They are all available on grafana.com:</p> <p>MySQL Overview</p> <p>MySQL Exporter Quickstart and Dashboard</p> <p>MySQL Replication</p> <p>Galera/MariaDB - Overview</p>"},{"location":"METRICS/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> </ul>"},{"location":"REGISTRY/","title":"Registry","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.27</p> <p>This documentation aims to provide guidance on how to configure private registries in the <code>mariadb-operator</code> CRs.</p>"},{"location":"REGISTRY/#table-of-contents","title":"Table of contents","text":"<ul> <li>Credentials</li> <li><code>MariaDB</code></li> <li><code>MaxScale</code></li> <li><code>Backup</code>, <code>Restore</code> and <code>SqlJob</code></li> </ul>"},{"location":"REGISTRY/#credentials","title":"Credentials","text":"<p>The first requirement to access a private registry is having credentials in the cluster that will be pulling the images. Kubernetes has a specific type of <code>Secret</code> <code>kubernetes.io/dockerconfigjson</code> designed specifically for this purpose. Please, refer to the Kubernetes documentation to see how it can be configured.</p> <p>For convenience, this repo provides a make target that can be used to configure your existing credentials available in <code>~/.docker/config</code> as a <code>kubernetes.io/dockerconfigjson</code> <code>Secret</code>:</p> <pre><code>REGISTRY_PULL_SECRET=registry DOCKER_CONFIG=~/.docker/config.json make registry-secret\n</code></pre>"},{"location":"REGISTRY/#mariadb","title":"<code>MariaDB</code>","text":"<p>In order to configure a private registry in your <code>MariaDB</code> resource, you can specify multiple <code>imagePullSecrets</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n  image: docker.mariadb.com/enterprise-server:10.6\n  imagePullPolicy: IfNotPresent\n  imagePullSecrets:\n    - name: registry\n    - name: another-registry\n</code></pre> <p>As a result, the <code>Pods</code> created as part of the reconciliation process will have the <code>imagePullSecrets</code>.</p> <p>You can also configure credentials for the metrics exporter:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n  metrics:\n    enabled: true\n    exporter:\n      image: prom/mysqld-exporter:v0.15.1\n      imagePullPolicy: IfNotPresent\n      imagePullSecrets:\n        - name: registry\n</code></pre> <p>By default, the metrics exporter <code>Pod</code> will inherit the credentials specified in the <code>imagePullSecrets</code> root field, but you can also specify dedicated credentials via <code>metrics.exporter.imagePullSecrets</code>.</p>"},{"location":"REGISTRY/#maxscale","title":"<code>MaxScale</code>","text":"<p>Similarly to <code>MariaDB</code>, you are able to configure private registries in your <code>MaxScale</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MaxScale\nmetadata:\n  name: maxscale\nspec:\n  ...\n  image: mariadb/maxscale:23.08\n  imagePullPolicy: IfNotPresent\n  imagePullSecrets:\n    - name: registry\n</code></pre>"},{"location":"REGISTRY/#backup-restore-and-sqljob","title":"<code>Backup</code>, <code>Restore</code> and <code>SqlJob</code>","text":"<p>The batch <code>Job</code> resources will inherit the <code>imagePullSecrets</code> from the referred <code>MariaDB</code>, as they also make use of its <code>image</code>. However, you are also able to provide dedicated <code>imagePullSecrets</code> for these resources:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n  image: docker.mariadb.com/enterprise-server:10.6\n  imagePullPolicy: IfNotPresent\n  imagePullSecrets:\n    - name: registry\n</code></pre> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Backup\nmetadata:\n  name: backup\nspec:\n  ...\n  mariaDbRef:\n    name: mariadb\n  imagePullSecrets:\n    - name: backup-registry\n</code></pre> <p>When the resources from the above examples are created, a <code>Job</code> with both <code>registry</code> and <code>backup-registry</code> <code>imagePullSecrets</code> will be reconciled.</p>"},{"location":"SQL_RESOURCES/","title":"SQL resources","text":"<p><code>mariadb-operator</code> enables you to manage SQL resources declaratively through CRs. By SQL resources, we refer to users, grants, and databases that are typically created using SQL statements.</p> <p>The key advantage of this approach is that, unlike executing SQL statements, which is a one-time operation, declaring a SQL resource via a CR ensures that the resource is periodically reconciled by the operator. This provides a guarantee that the resource will be recreated if it gets manually deleted. Additionally, it prevents state drifts, as the operator will regularly update the resource according to the CR specification.</p>"},{"location":"SQL_RESOURCES/#table-of-contents","title":"Table of contents","text":"<ul> <li><code>User</code> CR</li> <li><code>Grant</code> CR</li> <li><code>Database</code> CR</li> <li>Initial <code>User</code>, <code>Grant</code> and <code>Database</code></li> <li>Authentication plugins</li> <li>Configure reconciliation</li> <li>Cleanup policy</li> <li>Reference</li> </ul>"},{"location":"SQL_RESOURCES/#user-cr","title":"<code>User</code> CR","text":"<p>By creating this resource, you are declaring an intent to create an user in the referred <code>MariaDB</code> instance, just like a <code>CREATE USER</code> statement would do:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: User\nmetadata:\n  name: bob\nspec:\n  mariaDbRef:\n    name: mariadb\n  passwordSecretKeyRef:\n    name: bob-password\n    key: password\n  maxUserConnections: 20\n  host: \"%\"\n  cleanupPolicy: Delete  \n</code></pre> <p>In the example above, a user named <code>bob</code> identified by the password available in the <code>bob-password</code> <code>Secret</code> will be created in the <code>mariadb</code> instance.</p> <p>Refer to the reference section for more detailed information about every field.</p>"},{"location":"SQL_RESOURCES/#custom-name","title":"Custom name","text":"<p>By default, the CR name is used to create the user in the database, but you can specify a different one providing the <code>name</code> field under spec:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: User\nmetadata:\n  name: user\nspec:\n  name: user-custom\n</code></pre>"},{"location":"SQL_RESOURCES/#grant-cr","title":"<code>Grant</code> CR","text":"<p>By creating this resource, you are declaring an intent to grant permissions to a given user in the referred <code>MariaDB</code> instance, just like a <code>GRANT</code> statement would do.</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Grant\nmetadata:\n  name: grant-bob\nspec:\n  mariaDbRef:\n    name: mariadb\n  privileges:\n    - \"SELECT\"\n    - \"INSERT\"\n    - \"UPDATE\"\n  database: \"*\"\n  table: \"*\"\n  username: bob\n  grantOption: true\n  host: \"%\"\n</code></pre> <p>You may provide any set of privileges supported by MariaDB.</p> <p>Refer to the reference section for more detailed information about every field.</p>"},{"location":"SQL_RESOURCES/#database-cr","title":"<code>Database</code> CR","text":"<p>By creating this resource, you are declaring an intent to create a logical database in the referred <code>MariaDB</code> instance, just like a <code>CREATE DATABASE</code> statement would do:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Database\nmetadata:\n  name: wordpress\nspec:\n  mariaDbRef:\n    name: mariadb\n  characterSet: utf8\n  collate: utf8_general_ci\n</code></pre> <p>Refer to the reference section for more detailed information about every field.</p>"},{"location":"SQL_RESOURCES/#custom-name_1","title":"Custom name","text":"<p>By default, the CR name is used to create the user in the database, but you can specify a different one providing the <code>name</code> field under spec:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: Database\nmetadata:\n  name: database\nspec:\n  name: database-custom\n</code></pre>"},{"location":"SQL_RESOURCES/#initial-user-grant-and-database","title":"Initial <code>User</code>, <code>Grant</code> and <code>Database</code>","text":"<p>If you only need one user to interact with a single logical database, you can use of the <code>MariaDB</code> resource to configure it, instead of creating the <code>User</code>, <code>Grant</code> and <code>Database</code> resources separately:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  username: bob\n  passwordSecretKeyRef:\n    name: bob-password\n    key: password\n  database: wordpress\n</code></pre> <p>Behind the scenes, the operator will be creating an <code>User</code> resource with <code>ALL PRIVILEGES</code> in the initial <code>Database</code>. </p>"},{"location":"SQL_RESOURCES/#authentication-plugins","title":"Authentication plugins","text":"<p>Passwords can be supplied using the <code>passwordSecretKeyRef</code> field in the <code>User</code> CR. This is a reference to a <code>Secret</code> that contains a password in plain text. </p> <p>Alternatively, you can use MariaDB authentication plugins to avoid passing passwords in plain text and provide the password in a hashed format instead. This doesn't affect the end user experience, as they will still need to provide the password in plain text to authenticate.</p>"},{"location":"SQL_RESOURCES/#password-hash","title":"Password hash","text":"<p>Provide the password hashed using the MariaDB <code>PASSWORD</code> function:</p> <pre><code>kind: Secret\nmetadata:\n  name: mariadb-auth\nstringData:\n  passwordHash: \"*57685B4F0FF9D049082E296E2C39354B7A98774E\"\n---\napiVersion: k8s.mariadb.com/v1alpha1\nkind: User\nmetadata:\n  name: user-password-hash\nspec:\n  mariaDbRef:\n    name: mariadb\n  passwordHashSecretKeyRef:\n    name: mariadb-auth\n    key: passwordHash\n  host: \"%\"\n</code></pre> <p>The password hash can be obtained by executing <code>SELECT PASSWORD('&lt;password&gt;');</code> in an existing MariaDB installation.</p>"},{"location":"SQL_RESOURCES/#password-plugin","title":"Password plugin","text":"<p>Provide the password hashed using any of the available MariaDB authentication plugins, for example <code>mysql_native_password</code>:</p> <pre><code>kind: Secret\nmetadata:\n  name: mariadb-auth\nstringData:\n  passwordHash: \"*57685B4F0FF9D049082E296E2C39354B7A98774E\"\n  nativePasswordPlugin: mysql_native_password\n---\napiVersion: k8s.mariadb.com/v1alpha1\nkind: User\nmetadata:\n  name: user-password-plugin\nspec:\n  mariaDbRef:\n    name: mariadb\n  passwordPlugin:\n    pluginNameSecretKeyRef:\n        name: mariadb-auth\n        key: nativePasswordPlugin\n    pluginArgSecretKeyRef:\n        name: mariadb-auth\n        key: passwordHash\n  host: \"%\"\n</code></pre> <p>The plugin name should be available in a <code>Secret</code> referenced by <code>pluginNameSecretKeyRef</code> and the argument passed to it in <code>pluginArgSecretKeyRef</code>. The argument is the hashed password in most cases, refer to the MariaDB docs for further detail.</p>"},{"location":"SQL_RESOURCES/#configure-reconciliation","title":"Configure reconciliation","text":"<p>As we previously mentioned, SQL resources are periodically reconciled by the operator into SQL statements. You are able to configure the reconciliation interval using the following fields:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: User\nmetadata:\n  name: user\nspec:\n  requeueInterval: 30s\n  retryInterval: 5s\n</code></pre> <p>If the SQL statement executed by the operator is successful, it will schedule the next reconciliation cycle using the <code>requeueInterval</code>. If the statement encounters an error, the operator will use the <code>retryInterval</code> instead.</p>"},{"location":"SQL_RESOURCES/#cleanup-policy","title":"Cleanup policy","text":"<p>Whenever you delete a SQL resource, the operator will also delete the associated resource in the database. This is the default behaviour, that can also be achieved by setting <code>cleanupPolicy=Delete</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: User\nmetadata:\n  name: user\nspec:\n  cleanupPolicy: Delete\n</code></pre> <p>You can opt-out from this cleanup process using <code>cleanupPolicy=Skip</code>. Note that this resources will remain in the database.</p>"},{"location":"SQL_RESOURCES/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> </ul>"},{"location":"STORAGE/","title":"Storage","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.26</p> <p>This operator gives you flexibility to define the storage that will back the <code>/var/lib/mysql</code> data directoty mounted by <code>MariaDB</code>.</p>"},{"location":"STORAGE/#table-of-contents","title":"Table of contents","text":"<ul> <li>Configuration</li> <li>Volume resize</li> <li>Ephemeral storage</li> <li>Reference</li> </ul>"},{"location":"STORAGE/#configuration","title":"Configuration","text":"<p>The simplest way to configure storage for your <code>MariaDB</code> is:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  storage:\n    size: 1Gi\n</code></pre> <p>This will make use of the default <code>StorageClass</code> available in your cluster, but you can also provide a different one:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  storage:\n    size: 1Gi\n    storageClassName: my-storage-class\n</code></pre> <p>Under the scenes, the operator is configuring the <code>StatefulSet</code>'s <code>volumeClaimTemplate</code> property, which you are also able to provide yourself:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  storage:\n    size: 1Gi\n    storageClassName: standard\n    volumeClaimTemplate:\n      accessModes:\n      - ReadWriteOnce\n      resources:\n        requests:\n          storage: 1Gi\n      storageClassName: standard\n</code></pre>"},{"location":"STORAGE/#volume-resize","title":"Volume resize","text":"<p>[!WARNING] The <code>StorageClass</code> used for volume resizing must define <code>allowVolumeExpansion = true</code>.</p> <p>It is possible to resize your storage after having provisioned a <code>MariaDB</code>. We need to distinguish between: - PVCs already in use. - <code>StatefulSet</code> storage size, which will be used when provisioning new replicas.</p> <p>It is important to note that, for the first case, your <code>StorageClass</code> must support volume expansion by declaring the <code>allowVolumeExpansion = true</code>. In such case, it will be safe to expand the storage by increasing the <code>size</code> and setting <code>resizeInUseVolumes = true</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  storage:\n    size: 2Gi\n    resizeInUseVolumes: true\n    waitForVolumeResize: true\n</code></pre> <p>Depending on your storage provider, this operation might take a while, and you can decide to wait for this operation before the <code>MariaDB</code> becomes ready by setting <code>waitForVolumeResize = true</code>. Operations such as cluster recovery and primary switchover will not be performed if the <code>MariaDB</code> resource is not ready.</p>"},{"location":"STORAGE/#ephemeral-storage","title":"Ephemeral storage","text":"<p>Provisioning standalone <code>MariaDB</code> instances is also possible by setting <code>ephemeral = true</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  ...\n  storage:\n    ephemeral: true   \n</code></pre> <p>This may be useful more multiple use cases, like provisioning ephemeral <code>MariaDBs</code> for the integration tests of your CI.</p>"},{"location":"STORAGE/#reference","title":"Reference","text":"<ul> <li>API reference</li> <li>Example suite</li> </ul>"},{"location":"SUSPEND/","title":"Suspend","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.30</p>"},{"location":"SUSPEND/#table-of-contents","title":"Table of contents","text":"<ul> <li>Suspended state</li> <li>Suspend a resource</li> </ul>"},{"location":"SUSPEND/#suspended-state","title":"Suspended state","text":"<p>When a resource is suspended, all operations performed by the operator are disabled, including but not limited to: - Provisioning - Upgrades - Volume resize - Galera cluster recovery</p> <p>More specifically, the reconciliation loop of the operator is omitted, anything part of it will not happen while the resource is suspended. This could be useful in maintenance scenarios, where manual operations need to be performed, as it helps prevent conflicts with the operator.</p>"},{"location":"SUSPEND/#suspend-a-resource","title":"Suspend a resource","text":"<p>Currently, only <code>MariaDB</code> and <code>MaxScale</code> resources support suspension. You can enable it by setting <code>suspend=true</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  suspend: true\n</code></pre> <p>This results in the reconciliation loop being disabled and the status being marked as <code>Suspended</code>:</p> <pre><code>kubectl get mariadbs\nNAME             READY   STATUS      PRIMARY           UPDATES                   AGE\nmariadb-galera   True    Suspended   mariadb-galera-0  ReplicasFirstPrimaryLast  12m\n</code></pre> <p>To re-enable it, simply remove the <code>suspend</code> setting or set it to <code>suspend=false</code>.</p>"},{"location":"UPDATES/","title":"Updates","text":"<p>[!NOTE] This documentation applies to <code>mariadb-operator</code> version &gt;= v0.0.29</p> <p>By leveraging the automation provided by <code>mariadb-operator</code>, you can declaratively manage large fleets of databases using CRs. This also covers day two operations, such as upgrades, which can be risky when rolling out updates to thousands of instances simultaneously.</p> <p>To mitigate this, and to give you full control on the upgrade process, you are able to choose between multiple update strategies described in the following sections.</p>"},{"location":"UPDATES/#table-of-contents","title":"Table of contents","text":"<ul> <li>Update strategies</li> <li>Configuration</li> <li>Trigger updates</li> <li><code>ReplicasFirstPrimaryLast</code></li> <li><code>RollingUpdate</code></li> <li><code>OnDelete</code></li> <li><code>Never</code></li> <li>Data-plane updates</li> </ul>"},{"location":"UPDATES/#update-strategies","title":"Update strategies","text":"<p>In order to provide you with flexibility for updating <code>MariaDB</code> reliably, this operator supports multiple update strategies:</p> <ul> <li><code>ReplicasFirstPrimaryLast</code>: Roll out replica <code>Pods</code> one by one, wait for each of them to become ready, and then proceed with the primary <code>Pod</code>.</li> <li><code>RollingUpdate</code>: Utilize the rolling update strategy from Kubernetes. </li> <li><code>OnDelete</code>: Updates are performed manually by deleting <code>Pods</code>.</li> <li><code>Never</code>: Pause updates.</li> </ul>"},{"location":"UPDATES/#configuration","title":"Configuration","text":"<p>The update strategy can be configured in the <code>updateStrategy</code> field of the <code>MariaDB</code> resource:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  updateStrategy:\n    type: ReplicasFirstPrimaryLast\n</code></pre> <p>It defaults to <code>ReplicasFirstPrimaryLast</code> if not provided.</p>"},{"location":"UPDATES/#trigger-updates","title":"Trigger updates","text":"<p>Updates are not limited to updating the <code>image</code> field in the <code>MariaDB</code> resource, an update will be triggered whenever any field of the <code>Pod</code> template is changed. This translates into making changes to <code>MariaDB</code> fields that map directly or indirectly to the <code>Pod</code> template, for instance, the CPU and memory resources:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n- image: mariadb:10.11.7\n+ image: mariadb:10.11.8\n  resources:\n    requests:\n      cpu: 200m\n      memory: 128Mi\n    limits:\n-     memory: 1Gi\n+     memory: 2Gi\n</code></pre> <p>Once the update is triggered, the operator manages it differently based on the selected update strategy.</p>"},{"location":"UPDATES/#replicasfirstprimarylast","title":"<code>ReplicasFirstPrimaryLast</code>","text":"<p>This role-aware update strategy consists in rolling out the replica <code>Pods</code> one by one first, waiting for each of them become ready (i.e. readiness probe passed), and then proceed with the primary <code>Pod</code>. This is the default update strategy, as it can potentially meet various reliability requirements and minimize the risks associated with updates:</p> <ul> <li>Write operations won't be affected until all the replica <code>Pods</code> have been rolled out. If something goes wrong in the update, such as an update to an incompatible MariaDB version, this is detected early when the replicas are being rolled out and the update operation will be paused at that point.</li> <li>Read operations impact is minimized by only rolling one replica <code>Pod</code> at a time.</li> <li>Waiting for every <code>Pod</code> to be synced minimizes the impact in the clustering protocols and the network.</li> </ul>"},{"location":"UPDATES/#rollingupdate","title":"<code>RollingUpdate</code>","text":"<p>This strategy leverages the rolling update strategy from the <code>StatefulSet</code> resource, which, unlike <code>ReplicasFirstPrimaryLast</code>, does not take into account the role of the <code>Pods</code>(primary or replica). Instead, it rolls out the <code>Pods</code> one by one, from the highest to the lowest <code>StatefulSet</code> index.</p> <p>You are able to pass extra parameters to this strategy via the <code>rollingUpdate</code> object:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  ...\n  updateStrategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n</code></pre>"},{"location":"UPDATES/#ondelete","title":"<code>OnDelete</code>","text":"<p>This strategy aims to provide a method to update <code>MariaDB</code> resources manually by allowing the user to restart the <code>Pods</code> individually. This way, the user has full control over the update process and can decide which <code>Pods</code> are rolled out at any given time.</p> <p>Whenever an update is triggered, the <code>MariaDB</code> will be marked as pending to update:</p> <pre><code>kubectl get mariadbs\nNAME             READY   STATUS           PRIMARY            UPDATES    AGE\nmariadb-galera   True    Pending update   mariadb-galera-0   OnDelete   5m17s\n</code></pre> <p>From this point, you are able to delete the <code>Pods</code> to trigger the update, which will result the <code>MariaDB</code> marked as updating:</p> <pre><code>kubectl get mariadbs\nNAME             READY   STATUS         PRIMARY            UPDATES    AGE\nmariadb-galera   True    Updating       mariadb-galera-0   OnDelete   9m50s\n</code></pre> <p>Once all the <code>Pods</code> have been rolled out, the <code>MariaDB</code> resource will be back to a ready state:</p> <pre><code>NAME             READY   STATUS         PRIMARY            UPDATES    AGE\nmariadb-galera   True    Running        mariadb-galera-0   OnDelete   12m\n</code></pre>"},{"location":"UPDATES/#never","title":"<code>Never</code>","text":"<p>The operator will not perform updates on the <code>StatefulSet</code> whenever this update strategy is configured. This could be useful in multiple scenarios: - Progressive fleet upgrades: If you're managing large fleets of databases, you likely prefer to roll out updates progressively rather than simultaneously across all instances. - Operator upgrades: When upgrading <code>mariadb-operator</code>, changes to the <code>StatefulSet</code> or the <code>Pod</code> template may occur from one version to another, which could trigger a rolling update of your <code>MariaDB</code> instances.</p>"},{"location":"UPDATES/#data-plane-updates","title":"Data-plane updates","text":"<p>Galera relies on data-plane containers that run alongside MariaDB to implement provisioning and high availability operations on the cluster. These containers use the <code>mariadb-operator</code> image, which can be automatically updated by the operator based on its image version:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n    autoUpdateDataPlane: true\n</code></pre> <p>By default, <code>updateStrategy.autoUpdateDataPlane</code> is <code>false</code>, which means that no automatic upgrades will be performed, but you can opt-in/opt-out from this feature at any point in time by updating this field. For instance, you may want to selectively enable <code>updateStrategy.autoUpdateDataPlane</code> in a subset of your <code>MariaDB</code> instances after the operator has been upgraded to a newer version, and then disable it once the upgrades are completed.</p> <p>It is important to note that this feature is fully compatible with the <code>Never</code> strategy: no upgrades will happen when <code>updateStrategy.autoUpdateDataPlane=true</code> and <code>updateStrategy.type=Never</code>.</p>"},{"location":"releases/UPGRADE_0.34.0/","title":"Upgrade guide 0.34.0","text":"<p>This guide illustrates, step by step, how to migrate to <code>0.34.0</code> from previous versions. </p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator --replicas=0\nkubectl scale deployment mariadb-operator-webhook --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator-crds</code> to <code>0.34.0</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator-crds  mariadb-operator/mariadb-operator-crds --version 0.34.0\n</code></pre> <ul> <li>If you are using Galera, and you want the operator to automatically update the data-plane (i.e. init and agent containers) to <code>0.34.0</code>, you can set <code>updateStrategy.autoUpdateDataPlane=true</code> in your <code>MariaDB</code> resources:</li> </ul> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   autoUpdateDataPlane: true\n</code></pre> <p>Alternatively, you can also do this manually:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  galera:\n    agent:\n-      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.33\n+      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:0.34.0\n    initContainer:\n-      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.33\n+      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:0.34.0\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator</code> to <code>0.34.0</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.34.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator --replicas=1\nkubectl scale deployment mariadb-operator-webhook --replicas=1\n</code></pre> <ul> <li>If you previously set <code>updateStratety.autoUpdateDataPlane=true</code>, you may consider reverting the changes once the upgrades have finished:</li> </ul> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   autoUpdateDataPlane: false\n-   autoUpdateDataPlane: true\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.20/","title":"Upgrade guide v0.0.20","text":"<p>[!NOTE] APIs are currently in <code>v1alpha1</code>, which implies that non backward compatible changes might happen. See Kubernetes API versioning for more detail.</p> <p>This guide illustrates, step by step, how to migrate to <code>v0.0.20</code> from previous versions, as some breaking changes have been introduced. See: - https://github.com/mariadb-operator/mariadb-operator/pull/197 - https://github.com/mariadb-operator/mariadb-operator/pull/211</p> <p>It's important to note that this migration process only applies if: - You have created a <code>MariaDB</code> resource using a <code>mariadb-operator</code> version &lt; <code>v0.0.20</code> and you are upgrading to &gt;= <code>v0.0.20</code>. - Your <code>MariaDB</code> resource has <code>spec.replication</code> enabled.</p> <p>If that's your case follow these steps for upgrading:</p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=0\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>In case you are manually applying manifests, get a copy of your <code>MariaDB</code> resources, as the CRD upgrade will wipe out fields that are no longer supported:</li> </ul> <pre><code>kubectl get mariadb mariadb-repl -n default -o yaml &gt; mariadb-repl.yaml\n</code></pre> <ul> <li>Upgrade CRDs to <code>v0.0.20</code>: <p>[!IMPORTANT] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <p>[!WARNING] This step will delete fields that are no longer supported in your resources.</p> <pre><code>kubectl replace -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.20.0/crds.yaml\n</code></pre> <ul> <li>Perform migrations in your <code>MariaDB</code> resouces:</li> <li>Set <code>spec.replication.enabled = true</code>.</li> <li>If you had previously set <code>spec.replication.primary.service</code>, move it to <code>spec.primaryService</code>.</li> <li>Rename your resources to point to the new <code>&lt;mariadb-name&gt;-primary</code> <code>Service</code> instead of  <code>primary-&lt;mariadb-name&gt;</code>.</li> <li>If you had previously set  <code>spec.replication.primary.connection</code>, move it to <code>spec.primaryConnection</code>.</li> <li> <p>Rename your resources to point to the new <code>&lt;mariadb-name&gt;-primary</code> <code>Connection</code> instead of  <code>primary-&lt;mariadb-name&gt;</code>.</p> </li> <li> <p>Upgrade <code>mariadb-operator</code> to <code>v0.0.20</code>:</p> </li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.20.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.21/","title":"Upgrade guide v0.0.21","text":"<p>[!NOTE] APIs are currently in <code>v1alpha1</code>, which implies that non backward compatible changes might happen. See Kubernetes API versioning for more detail.</p> <p>This guide illustrates, step by step, how to migrate to <code>v0.0.21</code> from previous versions, as some breaking changes have been introduced. See: - https://github.com/mariadb-operator/mariadb-operator/pull/248</p> <p>Follow these steps for upgrading:</p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=0\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>In case you are manually applying manifests, get a copy of your <code>MariaDB</code> resources, as the CRD upgrade will wipe out fields that are no longer supported:</li> </ul> <pre><code>kubectl get mariadb mariadb-repl -n default -o yaml &gt; mariadb-repl.yaml\n</code></pre> <ul> <li>Upgrade CRDs to <code>v0.0.21</code>: <p>[!IMPORTANT] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <p>[!WARNING] This step will delete fields that are no longer supported in your resources.</p> <pre><code>kubectl replace -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.21.0/crds.yaml\n</code></pre> <ul> <li>Perform migrations in your <code>MariaDB</code> resouces:</li> <li><code>MariaDB</code> standalone migration    ```diff</li> <li>image:</li> <li>repository: mariadb</li> <li>tag: \"11.0.3\"</li> <li>pullPolicy: IfNotPresent</li> <li>image: mariadb:11.0.3</li> <li>imagePullPolicy: IfNotPresent    ```</li> <li><code>MariaDB</code> galera migration     ```diff</li> <li>image:</li> <li>repository: mariadb</li> <li>tag: \"11.0.3\"</li> <li>pullPolicy: IfNotPresent</li> <li>image: mariadb:11.0.3</li> <li>imagePullPolicy: IfNotPresent   galera:     agent:</li> <li>image:</li> <li>repository: ghcr.io/mariadb-operator/mariadb-operator</li> <li>tag: \"v0.0.25\"</li> <li>pullPolicy: IfNotPresent</li> <li>image: ghcr.io/mariadb-operator/mariadb-operator:v0.0.26</li> <li>imagePullPolicy: IfNotPresent     initContainer:</li> <li>image:</li> <li>repository: ghcr.io/mariadb-operator/init</li> <li>tag: \"v0.0.5\"</li> <li>pullPolicy: IfNotPresent</li> <li>image: ghcr.io/mariadb-operator/init:v0.0.6</li> <li> <p>imagePullPolicy: IfNotPresent    ```</p> </li> <li> <p>Upgrade <code>mariadb-operator</code> to <code>v0.0.21</code>:</p> </li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.21.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.24/","title":"Upgrade guide v0.0.24","text":"<p>[!NOTE] APIs are currently in <code>v1alpha1</code>, which implies that non backward compatible changes might happen. See Kubernetes API versioning for more detail.</p> <p>This guide illustrates, step by step, how to migrate to <code>v0.0.24</code> from previous versions, as some breaking changes have been introduced. See:</p> <p><code>MariaDB</code> - https://github.com/mariadb-operator/mariadb-operator/pull/248 - https://github.com/mariadb-operator/mariadb-operator/pull/312</p> <p><code>Backup</code> - https://github.com/mariadb-operator/mariadb-operator/pull/314</p> <p><code>Restore</code> - https://github.com/mariadb-operator/mariadb-operator/pull/308</p> <p>Follow these steps for upgrading:</p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator --replicas=0\nkubectl scale deployment mariadb-operator-webhook --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>In case you are manually applying manifests, get a copy of your <code>MariaDB</code>, <code>Backup</code> and <code>Restore</code> resources, as the CRD upgrade will wipe out fields that are no longer supported:</li> </ul> <pre><code>kubectl get mariadb mariadb -o yaml &gt; mariadb.yaml\nkubectl get backup backup -o yaml &gt; backup.yaml\nkubectl get restore restore -o yaml &gt; restore.yaml\n</code></pre> <ul> <li>Upgrade CRDs to <code>v0.0.24</code>: <p>[!IMPORTANT] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <p>[!WARNING] This step will delete fields that are no longer supported in your resources.</p> <pre><code>kubectl replace -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.24.0/crds.yaml\n</code></pre> <ul> <li>Perform migrations in your <code>MariaDB</code> resouces:</li> </ul> <pre><code>  metrics:\n+   enabled: true\n    exporter:\n-      image: prom/mysqld-exporter:v0.14.0\n+      image: prom/mysqld-exporter:v0.15.1\n</code></pre> <ul> <li>Perform migrations in your <code>Backup</code> resouces:</li> </ul> <pre><code>-  maxRetentionDays: 30\n+  maxRetention: 720h\n</code></pre> <ul> <li>Perform migrations in your <code>Restore</code> resouces:</li> </ul> <pre><code>-  fileName: backup.2023-12-19T09:00:00Z.sql\n+  targetRecoveryTime: 2023-12-19T09:00:00Z\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator</code> to <code>v0.0.24</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.24.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre> <ul> <li>If you have previously created <code>MariaDB</code> instances with metrics enabled and a single replica, we also need to perform the following changes in order to create a new <code>StatefulSet</code> with <code>spec.serviceName</code> pointing to the internal <code>Service</code>(see https://github.com/mariadb-operator/mariadb-operator/issues/319 for context):</li> </ul> <pre><code>kubectl delete statefulset mariadb --cascade=orphan\nkubectl rollout restart statefulset mariadb\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.26/","title":"Upgrade guide v0.0.26","text":"<p>[!NOTE] APIs are currently in <code>v1alpha1</code>, which implies that non backward compatible changes might happen. See Kubernetes API versioning for more detail.</p> <p>This guide illustrates, step by step, how to migrate to <code>v0.0.26</code> from previous versions, as some breaking changes have been introduced in the <code>MariaDB</code> resource. See the changes grouped by field:</p> <p><code>apiVersion</code> https://github.com/mariadb-operator/mariadb-operator/pull/418</p> <p><code>storage</code> https://github.com/mariadb-operator/mariadb-operator/pull/407</p> <p><code>serviceAccountName</code> https://github.com/mariadb-operator/mariadb-operator/pull/416</p> <p><code>galera</code> https://github.com/mariadb-operator/mariadb-operator/pull/384 https://github.com/mariadb-operator/mariadb-operator/pull/394</p> <p>Follow these steps for upgrading:</p> <ul> <li>In your current <code>mariadb-operator</code> version, make sure the <code>MariaDB</code> to migrate is in ready state and get a copy of its manifest: <p>[!IMPORTANT] <code>MariaDB</code> must be in ready state.</p> </li> </ul> <pre><code>kubectl get mariadbs.mariadb.mmontes.io mariadb-galera -o yaml &gt; mariadb-galera.yaml\n</code></pre> <ul> <li>Download and setup the migration script:</li> </ul> <pre><code>wget -q \"https://raw.githubusercontent.com/mariadb-operator/mariadb-operator/main/hack/migrate_v0.0.26.sh\"\nchmod +x migrate_v0.0.26.sh\n</code></pre> <ul> <li>Install <code>v0.0.26</code> CRDs: <p>[!NOTE] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <pre><code>kubectl apply --server-side=true --force-conflicts -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.26.0/crds.yaml\n</code></pre> <ul> <li>Execute the migration script:</li> </ul> <pre><code>./migrate_v0.0.26.sh mariadb-galera.yaml\n</code></pre> <ul> <li>Apply the <code>v0.0.26</code> specification:</li> </ul> <pre><code>kubectl apply -f migrated.mariadb-galera.yaml\n</code></pre> <ul> <li>Patch the <code>v0.0.26</code> status:</li> </ul> <pre><code>kubectl patch mariadbs.k8s.mariadb.com mariadb-galera --subresource status --type merge -p \"$(cat status.mariadb-galera.yaml)\"\n</code></pre> <ul> <li>Patch the <code>StatefulSet</code> <code>ownerReferences</code>. All the remaining children resources will be instantly recreated by the <code>v0.0.26</code> operator, but you might also patch them if you want: <p>[!WARNING] Not changing the <code>StatefulSet</code> <code>ownerReferences</code> implies that it will be garbage collected when deleting the old CRDs.</p> </li> </ul> <pre><code>MARIADB_UID=$(kubectl get mariadbs.k8s.mariadb.com mariadb-galera -o jsonpath=\"{.metadata.uid}\")\nkubectl patch statefulset mariadb-galera --type=json -p=\"[\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/metadata/ownerReferences/0/apiVersion\\\", \\\"value\\\": \\\"k8s.mariadb.com/v1alpha1\\\"}, \n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/metadata/ownerReferences/0/uid\\\", \\\"value\\\": \\\"${MARIADB_UID}\\\"}\n]\"\n</code></pre> <ul> <li>Uninstall you current <code>mariadb-operator</code>:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <ul> <li>If your <code>MariaDB</code> has Galera enabled, delete the <code>mariadb-galera</code> <code>Role</code>, as it will be specyfing the old CRDs:</li> </ul> <pre><code>kubectl delete role mariadb-galera\n</code></pre> <ul> <li>Install the current <code>mariadb-operator</code> version:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm install mariadb-operator mariadb-operator/mariadb-operator\n</code></pre> <ul> <li>Cleanup old CRDs and migration script:</li> </ul> <pre><code>OLD_HELM_VERSION=0.25.0\nkubectl delete -f \"https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-${OLD_HELM_VERSION}/crds.yaml\"\n</code></pre> <pre><code>rm migrate_v0.0.26.sh\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.28/","title":"Upgrade guide v0.0.28","text":"<p>[!NOTE] APIs are currently in <code>v1alpha1</code>, which implies that non backward compatible changes might happen. See Kubernetes API versioning for more detail.</p> <p>This guide illustrates, step by step, how to migrate to <code>v0.0.28</code> from previous versions, as some breaking changes have been introduced:</p> <ul> <li>Metadata: https://github.com/mariadb-operator/mariadb-operator/pull/537</li> <li>Affinity: https://github.com/mariadb-operator/mariadb-operator/pull/566 and https://github.com/mariadb-operator/mariadb-operator/pull/568</li> <li>Opt-in password generation: https://github.com/mariadb-operator/mariadb-operator/pull/598</li> </ul> <p>Follow these steps for upgrading:</p> <ul> <li>Install <code>v0.0.28</code> CRDs: <p>[!NOTE] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <pre><code>kubectl apply --server-side=true --force-conflicts -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.28.0/crds.yaml\n</code></pre> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator --replicas=0\nkubectl scale deployment mariadb-operator-webhook --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>In case you are manually applying manifests, get a copy of your resources, as the CRD upgrade will wipe out fields that are no longer supported:</li> </ul> <pre><code>kubectl get mariadb mariadb -o yaml &gt; mariadb.yaml\nkubectl get maxscale maxscale -o yaml &gt; maxscale.yaml\nkubectl get backup backup -o yaml &gt; backup.yaml\nkubectl get restore restore -o yaml &gt; restore.yaml\nkubectl get restore sqljob -o yaml &gt; sqljob.yaml\n</code></pre> <ul> <li>Upgrade CRDs to <code>v0.0.28</code>: <p>[!IMPORTANT] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <p>[!WARNING] This step will delete fields that are no longer supported in your resources.</p> <pre><code>kubectl replace -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.28.0/crds.yaml\n</code></pre> <ul> <li>Perform <code>metadata</code> related migrations in <code>MariaDB</code>, <code>MaxScale</code> and <code>Connection</code> resouces:</li> </ul> <pre><code>  storage:\n    volumeClaimTemplate:\n-     labels:\n-       k8s.mariadb.io/storage: \"fast\"\n-     annotations:\n-       k8s.mariadb.io/storage: \"fast\"\n+     metadata:\n+       labels:\n+         k8s.mariadb.io/storage: \"fast\"\n+       annotations:\n+         k8s.mariadb.io/storage: \"fast\"\n      accessModes:\n      - ReadWriteOnce\n      resources:\n        requests:\n          storage: 1Gi\n      storageClassName: standard\n\n  service:\n    type: LoadBalancer\n-   labels:\n-     k8s.mariadb.io/service: \"mysvc\"\n-   annotations:\n-     metallb.universe.tf/loadBalancerIPs: 172.18.0.150\n+   metadata:\n+     labels:\n+       k8s.mariadb.io/service: \"mysvc\"\n+     annotations:\n+       metallb.universe.tf/loadBalancerIPs: 172.18.0.150\n\n  connection:\n    secretName: mariadb-galera-conn\n    secretTemplate:\n-     labels:\n-       k8s.mariadb.io/secret: \"supersecret\"\n-     annotations:\n-       k8s.mariadb.io/secret: \"supersecret\"\n+     metadata:\n+       labels:\n+         k8s.mariadb.io/secret: \"supersecret\"\n+       annotations:\n+         k8s.mariadb.io/secret: \"supersecret\"\n      key: dsn\n\n  galera:\n    initJob:\n-     labels:\n-       sidecar.istio.io/inject: \"false\"\n-     annotations\n-       sidecar.istio.io/inject: \"false\"\n+     metadata:\n+       labels:\n+         sidecar.istio.io/inject: \"false\"\n+       annotations\n+         sidecar.istio.io/inject: \"false\"\n\n  bootstrapFrom:\n    restoreJob:\n-     labels:\n-       sidecar.istio.io/inject: \"false\"\n-     annotations\n-       sidecar.istio.io/inject: \"false\"\n+     metadata:\n+       labels:\n+         sidecar.istio.io/inject: \"false\"\n+       annotations\n+         sidecar.istio.io/inject: \"false\"\n</code></pre> <ul> <li>Perform <code>affinity</code> related migrations in <code>MariaDB</code>, <code>MaxScale</code>, <code>Backup</code>, <code>Restore</code> and <code>SqlJob</code> resources:</li> </ul> <pre><code>  affinity:\n-   enableAntiAffinity: true\n+   antiAffinityEnabled: true\n\n  galera:\n    initJob:\n      affinity:\n-       enableAntiAffinity: true\n+       antiAffinityEnabled: true\n\n  bootstrapFrom:\n    restoreJob:\n      affinity:\n-       enableAntiAffinity: true\n+       antiAffinityEnabled: true\n</code></pre> <ul> <li>Perform password generation migrations in <code>MariaDB</code> and <code>MaxScale</code> resources. This only applies if you are currently relying on <code>Secrets</code> generated by the operator:</li> </ul> <pre><code>-  rootPasswordSecretKeyRef:\n-    name: mariadb\n-    key: root-password\n+  rootPasswordSecretKeyRef:\n+    name: mariadb\n+    key: root-password\n+    generate: true\n\n-  passwordSecretKeyRef:\n-    name: mariadb\n-    key: root-password\n+  passwordSecretKeyRef:\n+    name: mariadb\n+    key: root-password\n+    generate: true\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator</code> to <code>v0.0.28</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.28.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.30/","title":"Upgrade guide v0.0.30","text":"<p>This guide illustrates, step by step, how to migrate to <code>v0.0.30</code> from previous versions. </p> <p>This release ships outstanding changes that make the Galera recovery process notably more robust. For making this possible, the <code>v0.0.30</code> operator relies some functionality available in both the <code>init</code> and <code>agent</code> containers used for Galera, so they both need to be updated to <code>v0.0.30</code> as detailed in further steps.</p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator --replicas=0\nkubectl scale deployment mariadb-operator-webhook --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>Upgrade CRDs to <code>v0.0.30</code>: <p>[!IMPORTANT] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <pre><code>kubectl replace -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.30.0/crds.yaml\n</code></pre> <ul> <li>If you are using Galera, apply the following changes in the <code>MariaDB</code> resources:</li> </ul> <p>Update the <code>init</code> and <code>agent</code> containers to <code>v0.0.30</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  galera:\n    agent:\n-      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.29\n+      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.30\n    initContainer:\n-      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.29\n+      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.30\n</code></pre> <p><code>podSyncTimeout</code> and <code>podRecoveryTimeout</code> defaults have been bumped to <code>5m</code>, make sure you bump them as well to at least <code>5m</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  galera:\n    recovery:\n-      podRecoveryTimeout: 3m\n+      podRecoveryTimeout: 5m\n-      podSyncTimeout: 3m\n+      podSyncTimeout: 5m\n</code></pre> <p><code>minClusterSize</code> defaults to <code>1</code> replica now, which means that the recovery process will only be triggered when all the <code>Pods</code> are down. This is the recommended setting now, as it fits better the new recovery process:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  galera:\n    recovery:\n-      minClusterSize: \"50%\"\n+      minClusterSize: 1\n</code></pre> <p>If you are using a service mesh like Istio or Linkerd, make sure you add the corresponding metadata to make sure that the new recovery <code>Jobs</code> complete, more information can be found here:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  galera:\n    recovery:\n+      job:\n+        metadata:\n+          labels:\n+            sidecar.istio.io/inject: \"false\"\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator</code> to <code>v0.0.30</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.30.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.31/","title":"Upgrade guide v0.0.31","text":"<p>This guide illustrates, step by step, how to migrate to <code>v0.0.31</code> from previous versions. </p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator --replicas=0\nkubectl scale deployment mariadb-operator-webhook --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>Upgrade CRDs to <code>v0.0.31</code>: <p>[!IMPORTANT] Helm does not handle CRD upgrades. See helm docs.</p> </li> </ul> <pre><code>kubectl replace -f https://github.com/mariadb-operator/mariadb-operator/releases/download/helm-chart-0.31.0/crds.yaml\n</code></pre> <ul> <li>If you are using Galera, apply the following changes in the <code>MariaDB</code> resources:</li> </ul> <p>Update the <code>init</code> and <code>agent</code> containers to <code>v0.0.31</code>:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb\nspec:\n  galera:\n    agent:\n-      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.30\n+      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.31\n    initContainer:\n-      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.30\n+      image: docker-registry3.mariadb.com/mariadb-operator/mariadb-operator:v0.0.31\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator</code> to <code>v0.0.31</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.31.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.32/","title":"Upgrade guide v0.0.32","text":"<p>This guide illustrates, step by step, how to migrate to <code>v0.0.32</code> from previous versions. </p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator --replicas=0\nkubectl scale deployment mariadb-operator-webhook --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>Helm has certain limitations when managing CRDs. Therefore, beginning with the current version, we will adopt this approach recommended in the official Helm documentation, which involves managing CRDs in a separate chart. First, let's specify the release name and namespace for installing the new <code>mariadb-operator-crds</code> chart:</li> </ul> <pre><code>export CRDS_RELEASE_NAME=\"&lt;HELM-RELEASE-NAME&gt;\" # e.g. mariadb-operator-crds\nexport CRDS_RELEASE_NAMESPACE=\"&lt;HELM-RELEASE-NAMESPASE&gt;\" # e.g. databases\n</code></pre> <ul> <li>If you installed previous versions of the <code>mariadb-operator</code> helm chart, you need to patch the CRDs to be owned by the new <code>mariadb-operator-crds</code> helm chart:</li> </ul> <pre><code>for crd in $(kubectl get crd -o jsonpath='{range .items[?(@.spec.group==\"k8s.mariadb.com\")]}{.metadata.name}{\"\\n\"}{end}'); do\n  kubectl annotate crd $crd \\\n    meta.helm.sh/release-name=$CRDS_RELEASE_NAME \\\n    meta.helm.sh/release-namespace=$CRDS_RELEASE_NAMESPACE --overwrite\n  kubectl label crd $crd \\\n    app.kubernetes.io/managed-by=Helm --overwrite\ndone\n</code></pre> <ul> <li>Install the new <code>mariadb-operator-crds</code> helm chart:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm install $CRDS_RELEASE_NAME -n $CRDS_RELEASE_NAMESPACE mariadb-operator/mariadb-operator-crds --version 0.0.32 \n</code></pre> <ul> <li>If you are using Galera, and you want the operator to automatically update the data-plane (i.e. init and agent containers) to <code>v0.0.32</code>, you can set <code>updateStrategy.autoUpdateDataPlane=true</code> in your <code>MariaDB</code> resources:</li> </ul> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   autoUpdateDataPlane: true\n</code></pre> <p>If want to progressively update your fleet of databases, you may also set <code>updateStrategy.type=Never</code> in some of them:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   type: Never\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator</code> to <code>v0.0.32</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.32.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre> <ul> <li>If you previously set <code>updateStratety.autoUpdateDataPlane=true</code> and/or <code>updateStratety.type=Never</code>, you may consider reverting the changes once the upgrades have finished:</li> </ul> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   type: ReplicasFirstPrimaryLast\n-   autoUpdateDataPlane: true\n</code></pre>"},{"location":"releases/UPGRADE_v0.0.33/","title":"Upgrade guide v0.0.33","text":"<p>This guide illustrates, step by step, how to migrate to <code>v0.0.33</code> from previous versions. </p> <ul> <li>Uninstall you current <code>mariadb-operator</code> for preventing conflicts:</li> </ul> <pre><code>helm uninstall mariadb-operator\n</code></pre> <p>Alternatively, you may only downscale and delete the webhook configurations:</p> <pre><code>kubectl scale deployment mariadb-operator --replicas=0\nkubectl scale deployment mariadb-operator-webhook --replicas=0\nkubectl delete validatingwebhookconfiguration mariadb-operator-webhook\nkubectl delete mutatingwebhookconfiguration mariadb-operator-webhook\n</code></pre> <ul> <li>Helm has certain limitations when managing CRDs. Therefore, beginning with the current version, we will adopt this approach recommended in the official Helm documentation, which involves managing CRDs in a separate chart. First, let's specify the release name and namespace for installing the new <code>mariadb-operator-crds</code> chart:</li> </ul> <pre><code>export CRDS_RELEASE_NAME=\"&lt;HELM-RELEASE-NAME&gt;\" # e.g. mariadb-operator-crds\nexport CRDS_RELEASE_NAMESPACE=\"&lt;HELM-RELEASE-NAMESPASE&gt;\" # e.g. databases\n</code></pre> <ul> <li>If you installed previous versions of the <code>mariadb-operator</code> helm chart, you need to patch the CRDs to be owned by the new <code>mariadb-operator-crds</code> helm chart:</li> </ul> <pre><code>for crd in $(kubectl get crd -o jsonpath='{range .items[?(@.spec.group==\"k8s.mariadb.com\")]}{.metadata.name}{\"\\n\"}{end}'); do\n  kubectl annotate crd $crd \\\n    meta.helm.sh/release-name=$CRDS_RELEASE_NAME \\\n    meta.helm.sh/release-namespace=$CRDS_RELEASE_NAMESPACE --overwrite\n  kubectl label crd $crd \\\n    app.kubernetes.io/managed-by=Helm --overwrite\ndone\n</code></pre> <ul> <li>Install the new <code>mariadb-operator-crds</code> helm chart:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm install $CRDS_RELEASE_NAME -n $CRDS_RELEASE_NAMESPACE mariadb-operator/mariadb-operator-crds --version 0.0.33 \n</code></pre> <ul> <li>If you are using Galera, and you want the operator to automatically update the data-plane (i.e. init and agent containers) to <code>v0.0.33</code>, you can set <code>updateStrategy.autoUpdateDataPlane=true</code> in your <code>MariaDB</code> resources:</li> </ul> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   autoUpdateDataPlane: true\n</code></pre> <p>If want to progressively update your fleet of databases, you may also set <code>updateStrategy.type=Never</code> in some of them:</p> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   type: Never\n</code></pre> <ul> <li>Upgrade <code>mariadb-operator</code> to <code>v0.0.33</code>:</li> </ul> <pre><code>helm repo update mariadb-operator\nhelm upgrade --install mariadb-operator mariadb-operator/mariadb-operator --version 0.33.0 \n</code></pre> <ul> <li>If you previously decided to downscale the operator, make sure you upscale it back:</li> </ul> <pre><code>kubectl scale deployment mariadb-operator -n default --replicas=1\nkubectl scale deployment mariadb-operator-webhook -n default --replicas=1\n</code></pre> <ul> <li>If you previously set <code>updateStratety.autoUpdateDataPlane=true</code> and/or <code>updateStratety.type=Never</code>, you may consider reverting the changes once the upgrades have finished:</li> </ul> <pre><code>apiVersion: k8s.mariadb.com/v1alpha1\nkind: MariaDB\nmetadata:\n  name: mariadb-galera\nspec:\n  updateStrategy:\n+   type: ReplicasFirstPrimaryLast\n-   autoUpdateDataPlane: true\n</code></pre>"}]}